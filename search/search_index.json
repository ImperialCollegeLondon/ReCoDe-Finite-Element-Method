{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#numerical-simulation-using-finite-element-method","title":"Numerical Simulation using Finite Element Method","text":""},{"location":"#description","title":"Description","text":"<p>Finite Element Method (FEM) is a powerful computational method used across a wide variety of disciplines, including engineering, mathematics and earth science. It is used to solve complex differential equations and simulate real-world scenarios. This project focuses on application of FEM in solid mechanics, but the teachings can be extended to other areas of study. It provides a comprehensive, step-by-step tutorial designed to introduce users to the fundamentals of FEM and its practical implementation in Python. The tutorial takes users through all the key stages of numerical simulations, starting from domain meshing and problem discretisation, moving to solving the differential equations and finally analysing and understanding the results. To make the learning process intuitive, the project works through two examples of increasing difficulty. The first example is straightforward and demonstrates the methodology and code implementation. As users progress, they are gradually introduced to more advanced aspects of FEM, ensuring a solid foundation and deeper understanding of this method.</p>"},{"location":"#learning-outcomes","title":"Learning Outcomes","text":"<ul> <li>Develop understanding of the fundaments of FEM</li> <li>Learn how to create custom FEM code and adapt it to solve partial differential equations</li> <li>Gain familiarity with existing libraries and tools available for FEM implementation</li> <li>Develop skills to interpret solutions and effectively analyse the simulation results</li> </ul> <p>In this project, the exercises are integrated with the theoretical components.</p> Task Time Reading 3 hours Practising 3 hours"},{"location":"#requirements","title":"Requirements","text":""},{"location":"#academic","title":"Academic","text":"<p>To successfully complete this examplar the user should have basic understanding of key mathematical concepts, including linear algebra (such as matrices, vectors, and determinants) and differential equations (both ordinary and partial differential equations, linear system of equations)</p> <p>Familiarity with Python programming, using existing libraries, writing classes, functions and graph plotting.</p>"},{"location":"#system","title":"System","text":"<p>System requirements: - Python 3.11 or newer - Paraview 4.0 or newer - Jupyter Notebooks</p> <p>Python libraries used: - pygmsh - numpy - matplotlib</p>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#finite-element-method-overview","title":"Finite Element Method Overview","text":"<p>A significant part of our understanding of the real world comes from differential equations, which describe the behaviour of various quantities. These equations are fundamental across many scientific fields, including physics, geoscience, and medicine, as they explain how systems behave under specific conditions, how they respond to external forces and change with time.</p> <p>Solving differential equations allows us to predict and analyse real world phenomena. In many cases, computer simulations are used to solve these equations for specific scenarios. Engineers use computer simulations to optimize product designs, ensuring they can withstand real world conditions, while geoscientists use them to study complex natural processes or our interactions with them, such as energy storage. These simulations enable us to test hypotheses and evaluate outcomes without the need for expensive real life experiments. However, their accuracy and reliability depend on our ability to effectively solve the underlying systems of differential equations.</p> <p>In certain simplified cases, differential equations can be solved analytically, providing exact solutions. However, these cases are often over simplified and may not be flexible enough for practical applications. When analytical solutions are not feasible, we use numerical methods to approximate solutions. A wide range of numerical techniques exists, each designed to solve specific problems and improve the accuracy and efficiency of the solutions.</p> <p>One of the most widely used numerical methods is the Finite Element Method (FEM). It is particularly popular in mechanics, including structural and rock mechanics, fluid dynamics, and heat transfer. Since its introduction in the 1950s, FEM has become an essential tool in numerical modeling, with extensive research dedicated to refining and advancing its capabilities.  </p> <p>The core principle of FEM is discretising the problem domain into smaller interconnected elements. This process, known as discretisation, allows the problem to be described at the element level. Each element has an associated number of nodes, which are shared by adjacent elements. These nodes form relationships between elements that can be aggregated to a global system of equations. Solving this system yields an approximate solution at the nodes across the domain. Interpolation then allows us to calculate the solution at any point.</p> <p>Therefore the key stages of Finite Element Methods are:</p> <ul> <li>Domain discretisation  -  dividing the domain into finite elements</li> <li>Element level problem formulation - defining the equations on each element using basis functions</li> <li>Assembly to global system - combining the element equations into a global system</li> <li>Application of boundary conditions - applying constrains and conditions to the problem to solve for unique solutions.</li> <li>Solving linear system of equations - using a numerical solver to find the solution</li> <li>Post processing of solution - interpreting, visualising and analysing the solution</li> </ul>"},{"location":"#project-overview","title":"Project Overview","text":"<p>The project is split into two main examples. Inside each examples there are smaller exercises that allow the user to apply and practice the theoretical components presented. For some exercises the user is expected to complete the code. The missing parts are indicated with <code>...</code> and the solutions are provided in the hidden cells marked \"Solution\" in red. By double-clicking on the hidden cells, the user can reference solutiona and copy and past into the code cells.</p> <p>This exercise will guide you through the key stages of constructing a Finite Element code. It will focus on a simple problem of heat transfer to build the basics of the method. At the end of this exercise you should have a good understanding of how FEM works.</p> <p>The next exercise will build on these concepts and look at solving a slightly more complex problem: an engineering problem where we solve for displacement vector. In this exercise we focus on applying different type of boundary conditions and analysing solution convergence to analytical solution.</p>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>\u2502   .gitignore\n\u2502   LICENSE.md\n\u2502   mkdocs.yml\n\u2502   README.md\n\u2502   requirements.txt\n\u2502\n\u251c\u2500\u2500\u2500.devcontainer\n\u2502       devcontainer.json\n\u2502       Dockerfile\n\u2502\n\u251c\u2500\u2500\u2500.github\n\u2502   \u2514\u2500\u2500\u2500workflows\n\u2502           docs.yml\n\u2502           link_checker.yml\n\u2502\n\u251c\u2500\u2500\u2500.ipynb_checkpoints\n\u251c\u2500\u2500\u2500docs\n\u2502   \u2502   index.md\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500\u2500.icons\n\u2502   \u2502   \u2514\u2500\u2500\u2500logos\n\u2502   \u2502           iclogo.svg\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500assets\n\u2502           iclogo.png\n\u2502\n\u251c\u2500\u2500\u2500FEM_Module\n\u2502   \u2502   FEM_Module_class.py\n\u2502   \u2502   Run_Cantilever_Example.py\n\u2502   \u2502   Support_functions.py\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500__pycache__\n\u2502           FEM_Module_class.cpython-311.pyc\n\u2502           Run_Cantilever_Example.cpython-311.pyc\n\u2502           Support_functions.cpython-311.pyc\n\u2502\n\u2514\u2500\u2500\u2500notebooks\n    \u2502   .placeholder\n    \u2502   Part_1.ipynb\n    \u2502   Part_2.ipynb\n    \u2502\n    \u251c\u2500\u2500\u2500.ipynb_checkpoints\n    \u2502       Part_1-checkpoint.ipynb\n    \u2502       Part_2-checkpoint.ipynb\n    \u2502       Part_2_withlinear-checkpoint.ipynb\n    \u2502\n    \u2514\u2500\u2500\u2500img\n            Cantilever_diagram.png\n            cantilever_result.png\n            element_in_mesh.png\n            element_types.png\n            hat_functions_as_basis.png\n            isoparametric_triangle.png\n            line_element_diag.png\n            mapping_to_isoparametric.png\n            rectangularmesh.png\n            rectangular_mesh_simple.png\n            temp_result.png\n            triangular_mesh.png\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD-3-Clause license</p>"},{"location":"Part_1/","title":"Exercise 1","text":"<p>However, more degrees of freedom also lead to larger linear system of equations. Similarly to the refinement considerations, it is a trade off between computational cost and solution error. In general, quadratic elements tend to be sufficient. However, if you have higher order differential equations it may be worth considering cubic.</p> In\u00a0[72]: Copied! <pre>import pygmsh\nimport numpy as np\nimport plotly.graph_objects as go\nimport os\nimport sys\nsys.path += [\".\", \"..\"]\n\n\n# ------------ User Input required --------------------#\n## Domain boundaries\nx_min = 0\nx_max = 10\ny_min = 0\ny_max = 1\n\ndegree = 2  # this is the degree of the elements that we are planning to use\n\n\nelement_size = 1 # this is the minimum element length.\n\n# ------------ End of User Input  --------------------#\n</pre> import pygmsh import numpy as np import plotly.graph_objects as go import os import sys sys.path += [\".\", \"..\"]   # ------------ User Input required --------------------# ## Domain boundaries x_min = 0 x_max = 10 y_min = 0 y_max = 1  degree = 2  # this is the degree of the elements that we are planning to use   element_size = 1 # this is the minimum element length.  # ------------ End of User Input  --------------------#  In\u00a0[73]: Copied! <pre>## Code to create the mesh and visualise it\nimport matplotlib.pyplot as plt\nfrom matplotlib.tri import Triangulation\n\n# Create a geometry and generate a mesh\nwith pygmsh.geo.Geometry() as geom:\n    # Define a square geometry (side length = 1)\n    square = geom.add_rectangle(xmin=x_min, xmax=x_max, ymin=y_min, ymax=y_max, z=0,  mesh_size=1)  # Approximate mesh size)\n\n    # Generate the mesh\n    mesh =  geom.generate_mesh(dim = 2, algorithm=6, order = degree) ## order 2 changes from linear to quadratic, element order\n    \npoints = mesh.points  # Coordinates of the mesh points\n\n## Visualising the mesh\npoints = mesh.points  # Coordinates of the mesh points\ncells = mesh.cells_dict  # Dictionary of cell types and their connectivity\n\n## define the name of elements in the mesh\nif degree == 1:\n    element_name = 'triangle'\nelif degree== 2:\n    element_name = 'triangle6'\n    \nif element_name in cells: ## this relies on the quadratic elements\n    triangles = np.array(cells[element_name])[:,:3] ## only grab the corner nodes and not the midnotes\nelse:\n    raise ValueError(\"The mesh does not contain triangular elements.\")\n\n# Prepare data for Triangulation\nx, y = points[:, 0], points[:, 1]\ntriangulation = Triangulation(x, y, triangles)\n\n# Plot the mesh\nplt.figure(figsize=(10, 5))\nplt.triplot(triangulation, color='blue', lw=0.8)\nplt.scatter(x, y, color='red', s=10, zorder=5)  # Highlight the points\nplt.title(\"Triangular Mesh Visualization\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.axis(\"equal\")\nplt.grid(True)\nplt.show()\n</pre> ## Code to create the mesh and visualise it import matplotlib.pyplot as plt from matplotlib.tri import Triangulation  # Create a geometry and generate a mesh with pygmsh.geo.Geometry() as geom:     # Define a square geometry (side length = 1)     square = geom.add_rectangle(xmin=x_min, xmax=x_max, ymin=y_min, ymax=y_max, z=0,  mesh_size=1)  # Approximate mesh size)      # Generate the mesh     mesh =  geom.generate_mesh(dim = 2, algorithm=6, order = degree) ## order 2 changes from linear to quadratic, element order      points = mesh.points  # Coordinates of the mesh points  ## Visualising the mesh points = mesh.points  # Coordinates of the mesh points cells = mesh.cells_dict  # Dictionary of cell types and their connectivity  ## define the name of elements in the mesh if degree == 1:     element_name = 'triangle' elif degree== 2:     element_name = 'triangle6'      if element_name in cells: ## this relies on the quadratic elements     triangles = np.array(cells[element_name])[:,:3] ## only grab the corner nodes and not the midnotes else:     raise ValueError(\"The mesh does not contain triangular elements.\")  # Prepare data for Triangulation x, y = points[:, 0], points[:, 1] triangulation = Triangulation(x, y, triangles)  # Plot the mesh plt.figure(figsize=(10, 5)) plt.triplot(triangulation, color='blue', lw=0.8) plt.scatter(x, y, color='red', s=10, zorder=5)  # Highlight the points plt.title(\"Triangular Mesh Visualization\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.axis(\"equal\") plt.grid(True) plt.show()  <p>Every basis function is associated with a node in the element. The basis functions must satisfy the following properties:</p> <ul> <li><p>Compact Support:  basis function is defined only within a single finite element or a limited number of elements and is zero elsewhere.</p> </li> <li><p>Interpolation Property : the basis function must be of value 1 at the corresponding node and 0 for at all other nodes.</p> </li> <li><p>Partition of Unity : the sum of all non-zero basis functions at point $x$ must be 1, $$\\sum_i N_i(x) = 1$$</p> </li> </ul> <p>A simple example of basis functions are hat functions. For a linear line element where the nodes are places at values $x=0$ and $x=1$ the corresponding basis functions would be $\\phi_0$ and $\\phi_1$ defined as in the image below over interval $[-1,2]$</p> <p>We can see that $\\phi_0$ is 1 at the node $0$ and it linearly reduces to $0$ at the neighbouring nodes. That linear behaviour between the nodes makes it a linear element.</p> <p>For a unit triangle of degree 2 with six nodes there are six corresponding basis functions detailed below.</p> $\\phi_0 = (1-s-r)(1-2r-2s)$ $\\phi_1 = r(2r-1)$ $\\phi_2=s(2s-1)$ $\\phi_3=4r(1-r-s)$ $\\phi_4=4rs$ $\\phi_5=4s(1-r-s)$ (1) In\u00a0[74]: Copied! <pre># ------------ User Input required --------------------#\n# In the list below put up to three node IDs of the basis functions to be view\nshow_basis_fn=[0,3,1] # e.g. [0,3,1]\n\n# ------------ End of User Input  --------------------#\n</pre>  # ------------ User Input required --------------------# # In the list below put up to three node IDs of the basis functions to be view show_basis_fn=[0,3,1] # e.g. [0,3,1]  # ------------ End of User Input  --------------------# In\u00a0[75]: Copied! <pre>#This is for elements in 2D\ndef basis_functions(degree, point):\n    ## Givent the coordinate of the integration point in the local coordinate system\n    ## we evaulate the basis functions at that point \n    \n    r = point[0]\n    s = point[1]\n    \n    if degree == 1:\n        basis_functions = np.zeros((3,)) ## for each basis function\n        ## Corner nodes first\n        basis_functions[0] = (1 - s - r)\n        basis_functions[1] = r \n        basis_functions[2] = s  \n        \n    ## quadratic elements\n    if degree==2:\n        basis_functions = np.zeros((6,)) ## for each basis function\n        ## Corner nodes first\n        basis_functions[0] = (1 - s - r)*(1-2*r-2*s)\n        basis_functions[1] = r * (2*r - 1)\n        basis_functions[2] = s * (2*s - 1)#\n        #mid side nodes:\n        \n        basis_functions[3] = 4*r*(1-r-s)\n        basis_functions[4] = 4*r*s\n        basis_functions[5] = 4*s*(1-r-s)\n        \n    return basis_functions\n</pre> #This is for elements in 2D def basis_functions(degree, point):     ## Givent the coordinate of the integration point in the local coordinate system     ## we evaulate the basis functions at that point           r = point[0]     s = point[1]          if degree == 1:         basis_functions = np.zeros((3,)) ## for each basis function         ## Corner nodes first         basis_functions[0] = (1 - s - r)         basis_functions[1] = r          basis_functions[2] = s                ## quadratic elements     if degree==2:         basis_functions = np.zeros((6,)) ## for each basis function         ## Corner nodes first         basis_functions[0] = (1 - s - r)*(1-2*r-2*s)         basis_functions[1] = r * (2*r - 1)         basis_functions[2] = s * (2*s - 1)#         #mid side nodes:                  basis_functions[3] = 4*r*(1-r-s)         basis_functions[4] = 4*r*s         basis_functions[5] = 4*s*(1-r-s)              return basis_functions In\u00a0[76]: Copied! <pre>from FEM_Module.Support_functions import visualise_basis_fn\n# function to visualise the basis functions\nvisualise_basis_fn(show_basis_fn, basis_functions)\n</pre> from FEM_Module.Support_functions import visualise_basis_fn # function to visualise the basis functions visualise_basis_fn(show_basis_fn, basis_functions) In\u00a0[8]: Copied! <pre># ------------ User Input required --------------------#\ndef basis_functions_dNs(degree,point):\n    # Derivative of basis functions with respect to s\n    r = point[0]\n    s = point[1]\n    if degree == 1:\n        dNs = np.zeros((3,)) ## for each basis function\n        ## Corner nodes first\n        dNs[0] = -1\n        dNs[1] = 0.\n        dNs[2] = 1.\n\n    if degree==2:\n        dNs = np.zeros((6,)) ## for each basis function\n        ## Corner nodes first\n        dNs[0] = ...\n        dNs[1] = ...\n        dNs[2] = ...\n\n        dNs[3] = ...\n        dNs[4] = ...\n        dNs[5] = ...\n\n    return dNs\n# -------------- End of User Input ------------------------#\n\n\ndef basis_functions_der(degree, point):\n    ## Givent the coordinate of the point in the local coordinate system (r,s)\n    ## we evaulate the basis functions at that point \n\n    ## linear elements\n    if degree == 1:\n        dNr = basis_functions_dNr(1,point)\n        dNs = basis_functions_dNs(1,point)\n       \n        basis_functions = np.vstack((dNr,dNs)) \n        \n    ## quadratic elements\n    if degree==2:\n        dNr = basis_functions_dNr(2,point)\n        dNs = basis_functions_dNs(2,point)\n        basis_functions = np.vstack((dNr,dNs))\n        \n    return basis_functions\n\n\ndef basis_functions_dNr(degree,point):\n    # Derivative of basis functions with respect to r\n    r = point[0]\n    s = point[1]\n    \n    # linear eleemnt\n    if degree == 1:\n        dNr = np.zeros((3,)) ## for each basis function\n        ## Corner nodes first\n        dNr[0] = -1\n        dNr[1] = 1\n        dNr[2] = 0.\n\n    \n    if degree==2:\n        dNr = np.zeros((6,)) \n        ## Corner nodes first\n        dNr[0] = -3. + 4. * r + 4. * s\n        dNr[1] = -1. + 4. * r\n        dNr[2] = 0.\n\n        dNr[3] = 4. - 8. * r - 4. * s\n        dNr[4] = 4. * s\n        dNr[5] = -4*s\n    return dNr\n        \n\n               \n        \n</pre> # ------------ User Input required --------------------# def basis_functions_dNs(degree,point):     # Derivative of basis functions with respect to s     r = point[0]     s = point[1]     if degree == 1:         dNs = np.zeros((3,)) ## for each basis function         ## Corner nodes first         dNs[0] = -1         dNs[1] = 0.         dNs[2] = 1.      if degree==2:         dNs = np.zeros((6,)) ## for each basis function         ## Corner nodes first         dNs[0] = ...         dNs[1] = ...         dNs[2] = ...          dNs[3] = ...         dNs[4] = ...         dNs[5] = ...      return dNs # -------------- End of User Input ------------------------#   def basis_functions_der(degree, point):     ## Givent the coordinate of the point in the local coordinate system (r,s)     ## we evaulate the basis functions at that point       ## linear elements     if degree == 1:         dNr = basis_functions_dNr(1,point)         dNs = basis_functions_dNs(1,point)                 basis_functions = np.vstack((dNr,dNs))               ## quadratic elements     if degree==2:         dNr = basis_functions_dNr(2,point)         dNs = basis_functions_dNs(2,point)         basis_functions = np.vstack((dNr,dNs))              return basis_functions   def basis_functions_dNr(degree,point):     # Derivative of basis functions with respect to r     r = point[0]     s = point[1]          # linear eleemnt     if degree == 1:         dNr = np.zeros((3,)) ## for each basis function         ## Corner nodes first         dNr[0] = -1         dNr[1] = 1         dNr[2] = 0.           if degree==2:         dNr = np.zeros((6,))          ## Corner nodes first         dNr[0] = -3. + 4. * r + 4. * s         dNr[1] = -1. + 4. * r         dNr[2] = 0.          dNr[3] = 4. - 8. * r - 4. * s         dNr[4] = 4. * s         dNr[5] = -4*s     return dNr                                    In\u00a0[78]: Copied! <pre># ------------ User Input required --------------------#\ndef basis_functions_dNs(degree,point):\n    # Derivative of basis functions with respect to s\n    r = point[0]\n    s = point[1]\n\n    if degree==2:\n        dNs = np.zeros((6,)) ## for each basis function\n        ## Corner nodes first\n        dNs[0] = -3. + 4. * r + 4. * s\n        dNs[1] = 0.\n        dNs[2] = -1. + 4. * s\n\n        dNs[3] = -4. * r\n        dNs[4] =  4. * r\n        dNs[5] = 4. - 4. * r - 8. * s\n\n    return dNs\n\n\n# -------------- End of User Input ------------------------#\n\n\ndef basis_functions_der(degree, point):\n    ## Givent the coordinate of the point in the local coordinate system (r,s)\n    ## we evaulate the basis functions at that point \n\n    ## linear elements\n    if degree == 1:\n        dNr = basis_functions_dNr(1,point)\n        dNs = basis_functions_dNs(1,point)\n       \n        basis_functions = np.vstack((dNr,dNs)) \n        \n    ## quadratic elements\n    if degree==2:\n        dNr = basis_functions_dNr(2,point)\n        dNs = basis_functions_dNs(2,point)\n        basis_functions = np.vstack((dNr,dNs))\n        \n    return basis_functions\n\n\ndef basis_functions_dNr(degree,point):\n    # Derivative of basis functions with respect to r\n    r = point[0]\n    s = point[1]\n    \n    # linear eleemnt\n    if degree == 1:\n        dNr = np.zeros((3,)) ## for each basis function\n        ## Corner nodes first\n        dNr[0] = -1\n        dNr[1] = 1\n        dNr[2] = 0.\n\n    \n    if degree==2:\n        dNr = np.zeros((6,)) \n        ## Corner nodes first\n        dNr[0] = -3. + 4. * r + 4. * s\n        dNr[1] = -1. + 4. * r\n        dNr[2] = 0.\n\n        dNr[3] = 4. - 8. * r - 4. * s\n        dNr[4] = 4. * s\n        dNr[5] = -4*s\n    return dNr\n        \n\n               \n        \n</pre> # ------------ User Input required --------------------# def basis_functions_dNs(degree,point):     # Derivative of basis functions with respect to s     r = point[0]     s = point[1]      if degree==2:         dNs = np.zeros((6,)) ## for each basis function         ## Corner nodes first         dNs[0] = -3. + 4. * r + 4. * s         dNs[1] = 0.         dNs[2] = -1. + 4. * s          dNs[3] = -4. * r         dNs[4] =  4. * r         dNs[5] = 4. - 4. * r - 8. * s      return dNs   # -------------- End of User Input ------------------------#   def basis_functions_der(degree, point):     ## Givent the coordinate of the point in the local coordinate system (r,s)     ## we evaulate the basis functions at that point       ## linear elements     if degree == 1:         dNr = basis_functions_dNr(1,point)         dNs = basis_functions_dNs(1,point)                 basis_functions = np.vstack((dNr,dNs))               ## quadratic elements     if degree==2:         dNr = basis_functions_dNr(2,point)         dNs = basis_functions_dNs(2,point)         basis_functions = np.vstack((dNr,dNs))              return basis_functions   def basis_functions_dNr(degree,point):     # Derivative of basis functions with respect to r     r = point[0]     s = point[1]          # linear eleemnt     if degree == 1:         dNr = np.zeros((3,)) ## for each basis function         ## Corner nodes first         dNr[0] = -1         dNr[1] = 1         dNr[2] = 0.           if degree==2:         dNr = np.zeros((6,))          ## Corner nodes first         dNr[0] = -3. + 4. * r + 4. * s         dNr[1] = -1. + 4. * r         dNr[2] = 0.          dNr[3] = 4. - 8. * r - 4. * s         dNr[4] = 4. * s         dNr[5] = -4*s     return dNr                                    Solution. (*Hidden content here, visible but not collapsible on GitHub.*)  <p>The $B$ matrix is $$B= \\begin{bmatrix} -3 +4r+4s &amp; -1+4r &amp; 0 &amp; 4-8r-4s &amp; 4s &amp; -4s\\\\ -3+4r+4s &amp; 0 &amp; -1+4s &amp; -4r &amp; 4r&amp; 4-4r-8s \\end{bmatrix} $$ and the functions should look similar to the following. Copy from here-&gt;&gt; ``` def basis_functions_dNs(degree,point): # Derivative of basis functions with respect to s r = point[0] s = point[1]</p> <pre><code>if degree==2:\n    dNs = np.zeros((6,)) ## for each basis function\n    ## Corner nodes first\n    dNs[0] = -3. + 4. * r + 4. * s\n    dNs[1] = 0.\n    dNs[2] = -1. + 4. * s\n\n    dNs[3] = -4. * r\n    dNs[4] =  4. * r\n    dNs[5] = 4. - 4. * r - 8. * s\n\nreturn dNs\n```</code></pre> In\u00a0[17]: Copied! <pre>### Basis functions for linear quadrilateral element at a point\n### the local r axis is along x dimension and s is along the y dimension\ndef basis_fn_quad_linear(point):\n    r = point[0]\n    s = point[1]\n    \n    basis_functions = np.zeros((4,)) ## for each basis function\n    \n    ## Corner nodes first\n    basis_functions[0] = 0.25 * (1 - r)*(1 - s)\n    basis_functions[1] = ...\n    basis_functions[2] = ...\n    basis_functions[2] = ...\n\n        \n    return basis_functions\n\n                \n### Derivatives of the linear quadrilateral element\ndef basis_fn_quad_linear_der_dNr(degree,point):\n    # Derivative of basis functions with respect to r\n    r = point[0]\n    s = point[1]\n    \n\n    dNr = np.zeros((4,)) \n    dNr[0] = ...\n    dNr[1] = ...\n    dNr[2] = ...\n    dNr[3] = ...\n        \n    return dNr\n        \ndef basis_fn_quad_linear_der_dNs(degree,point):\n    # Derivative of basis functions with respect to s\n    r = point[0]\n    s = point[1]\n    \n    dNs = np.zeros((4,)) ## for each basis function\n    ## Corner nodes first\n    dNs[0] = ...\n    dNs[1] = ...\n    dNs[2] = ...\n    dNs[3] = ...\n\n    return dNs\n        \n               \n\ndef basis_fn_quad_linear_der(degree, point):\n    ## Givent the coordinate of the point in the local coordinate system (r,s)\n    ## we evaulate the basis functions at that point \n    \n    ## linear elements\n    if degree == 1:\n        dNr = basis_fn_quad_linear_der_dNr(1,point)\n        dNs = basis_fn_quad_linear_der_dNs(1,point)\n       \n        basis_functions = np.vstack((dNr,dNs)) \n        \n    return basis_functions\n</pre> ### Basis functions for linear quadrilateral element at a point ### the local r axis is along x dimension and s is along the y dimension def basis_fn_quad_linear(point):     r = point[0]     s = point[1]          basis_functions = np.zeros((4,)) ## for each basis function          ## Corner nodes first     basis_functions[0] = 0.25 * (1 - r)*(1 - s)     basis_functions[1] = ...     basis_functions[2] = ...     basis_functions[2] = ...               return basis_functions                   ### Derivatives of the linear quadrilateral element def basis_fn_quad_linear_der_dNr(degree,point):     # Derivative of basis functions with respect to r     r = point[0]     s = point[1]           dNr = np.zeros((4,))      dNr[0] = ...     dNr[1] = ...     dNr[2] = ...     dNr[3] = ...              return dNr          def basis_fn_quad_linear_der_dNs(degree,point):     # Derivative of basis functions with respect to s     r = point[0]     s = point[1]          dNs = np.zeros((4,)) ## for each basis function     ## Corner nodes first     dNs[0] = ...     dNs[1] = ...     dNs[2] = ...     dNs[3] = ...      return dNs                           def basis_fn_quad_linear_der(degree, point):     ## Givent the coordinate of the point in the local coordinate system (r,s)     ## we evaulate the basis functions at that point           ## linear elements     if degree == 1:         dNr = basis_fn_quad_linear_der_dNr(1,point)         dNs = basis_fn_quad_linear_der_dNs(1,point)                 basis_functions = np.vstack((dNr,dNs))               return basis_functions Solution. (*Hidden content here, visible but not collapsible on GitHub.*)  ``` ### Basis functions for linear quadrilateral element at a point ### the local r axis is along x dimension and s is along the y dimension def basis_fn_quad_linear(point):     r = point[0]     s = point[1]  <pre><code>basis_functions = np.zeros((4,)) ## for each basis function\n\n## Corner nodes first\nbasis_functions[0] = 0.25 * (1 - r)*(1 - s)\nbasis_functions[1] = 0.25 * (1 + r)*(1 - s)\nbasis_functions[2] = 0.25 * (1 + r)*(1 + s)\nbasis_functions[2] = 0.25 * (1 - r)*(1 + s)\n\n    \nreturn basis_functions\n\n            </code></pre> In\u00a0[79]: Copied! <pre>def jacobian(degree, point, e_nodes):\n    #e_nodes is numpy array (num_nodes, 2) of all the global coordinates of the nodes\n    space_dim = 2 ## for now we assume dimension is 2\n    \n    ## in this case we are mapping 2D space to 2D so Jacobian is a square\n    Jacobian_mat = np.zeros((space_dim,space_dim))\n    \n    dnr = basis_functions_dNr(degree, point)\n    dns = basis_functions_dNs(degree, point)\n\n    for dim in range(2):\n        Jacobian_mat[0,dim] =np.dot(dnr, e_nodes[:,dim])# x coordinate\n        Jacobian_mat[1,dim] =np.dot(dns, e_nodes[:,dim])# y coordinate\n    \n    det = np.linalg.det(Jacobian_mat)\n    return det, Jacobian_mat\n        \n    \n</pre> def jacobian(degree, point, e_nodes):     #e_nodes is numpy array (num_nodes, 2) of all the global coordinates of the nodes     space_dim = 2 ## for now we assume dimension is 2          ## in this case we are mapping 2D space to 2D so Jacobian is a square     Jacobian_mat = np.zeros((space_dim,space_dim))          dnr = basis_functions_dNr(degree, point)     dns = basis_functions_dNs(degree, point)      for dim in range(2):         Jacobian_mat[0,dim] =np.dot(dnr, e_nodes[:,dim])# x coordinate         Jacobian_mat[1,dim] =np.dot(dns, e_nodes[:,dim])# y coordinate          det = np.linalg.det(Jacobian_mat)     return det, Jacobian_mat               In\u00a0[80]: Copied! <pre>## Quadratic tirangular elements\ndef integration_points(degree):\n    Points = np.array([[1/6.,2/3.],[1/6.,1/6],[2/3.,1/6.]])\n    weights = np.array([1/6.,1/6.,1/6.,1/6.])\n\n    return Points, weights\n</pre> ## Quadratic tirangular elements def integration_points(degree):     Points = np.array([[1/6.,2/3.],[1/6.,1/6],[2/3.,1/6.]])     weights = np.array([1/6.,1/6.,1/6.,1/6.])      return Points, weights  In\u00a0[20]: Copied! <pre># ------------ User Input required --------------------#\nquad_mesh_connectivity=[[...],[...],[...],[...],[...],[...]]\n\n# ------------ End of User Input  --------------------#\n</pre>  # ------------ User Input required --------------------# quad_mesh_connectivity=[[...],[...],[...],[...],[...],[...]]  # ------------ End of User Input  --------------------# Solution.(*Hidden content here, visible but not collapsible on GitHub.*)     quad_mesh_connectivity=[[0,1,7,6],[1,2,8,7],[2,3,9,8],[3,4,10,9],[4,5,11,10]]     ```  In\u00a0[81]: Copied! <pre># Set up \nnum_nodes = len(points) # total number of nodes \nMatrixThermalConduct = 51.9615 # this depends on the material \nspace_dim = 2 # domain space dimension\nprint(\"There are \", num_nodes, \" nodes in the mesh\")\n\n# Set up the empty linear system of equations\nA_matrix = np.zeros((num_nodes, num_nodes))\nb = np.zeros((num_nodes,))\n</pre> # Set up  num_nodes = len(points) # total number of nodes  MatrixThermalConduct = 51.9615 # this depends on the material  space_dim = 2 # domain space dimension print(\"There are \", num_nodes, \" nodes in the mesh\")  # Set up the empty linear system of equations A_matrix = np.zeros((num_nodes, num_nodes)) b = np.zeros((num_nodes,)) <pre>There are  103  nodes in the mesh\n</pre> <p>For every element the order of accumulating the element stiffness matrix is:</p> <ul> <li>Get the list of integration points and the list of global coordinates of nodes</li> <li>Create an empty element stiffness matrix</li> <li>For each integration points:<ul> <li>calculate the basis functions or their derivatives at the integration point</li> <li>using the weak form equation multiply out the basis function</li> <li>multiply by the material properties</li> <li>calculate the Jacobian matrix and its determinant</li> <li>multiply by the weight of the integration points and the Jacobian determinant</li> <li>add to the element stiffness matrix</li> </ul> </li> <li>Add to the global matrix $A$ using the connectivity matrix</li> </ul> In\u00a0[82]: Copied! <pre>## Iterate through each element in the mesh \nfor element in cells[element_name]:\n    \n    # get the list of integration points and the list of global IDs for nodes in the element\n    IntegrationPoints, IP_weights = integration_points(degree)\n    e_nodes_xy = points[element][:,:space_dim]\n    \n    ## we first get the local stiffness matrix for the element by accumulating\n    ## over all the integration points\n    LHS = np.zeros((len(element), len(element)))\n    for IP, weight in zip(IntegrationPoints,IP_weights):\n        B = basis_functions_der(degree, IP)\n        BT = B.transpose() * MatrixThermalConduct\n        BT = np.matmul(BT, B)\n        detJ, _ = jacobian(degree, IP, e_nodes_xy)\n        BT = BT * weight*(detJ) \n        LHS += BT # this is a element level stiffness matrix\n        \n    ## once LHS has been accumulated over all the integration points, we add it to the global matrix A_matrix\n    ## this uses the global node IDs to determine which indices are updates\n    for i in range(len(element)):\n        for j in range(len(element)):\n            col = int(element[i])\n            row = int(element[j])\n            A_matrix[row][col]+= LHS[int(j)][int(i)]\n</pre>  ## Iterate through each element in the mesh  for element in cells[element_name]:          # get the list of integration points and the list of global IDs for nodes in the element     IntegrationPoints, IP_weights = integration_points(degree)     e_nodes_xy = points[element][:,:space_dim]          ## we first get the local stiffness matrix for the element by accumulating     ## over all the integration points     LHS = np.zeros((len(element), len(element)))     for IP, weight in zip(IntegrationPoints,IP_weights):         B = basis_functions_der(degree, IP)         BT = B.transpose() * MatrixThermalConduct         BT = np.matmul(BT, B)         detJ, _ = jacobian(degree, IP, e_nodes_xy)         BT = BT * weight*(detJ)          LHS += BT # this is a element level stiffness matrix              ## once LHS has been accumulated over all the integration points, we add it to the global matrix A_matrix     ## this uses the global node IDs to determine which indices are updates     for i in range(len(element)):         for j in range(len(element)):             col = int(element[i])             row = int(element[j])             A_matrix[row][col]+= LHS[int(j)][int(i)]  In\u00a0[83]: Copied! <pre>## identify the nodes along the right and left boundaries\n\nright_ = np.where(mesh.points[:, 0] == 10)[0]\nleft_ = np.where(mesh.points[:, 0] == 0)[0]\ntop_ = np.where(mesh.points[:,1] == 1)[0]\nbottom_=np.where(mesh.points[:,1] == 0)[0]\n\n## Check that the coordinates of the nodes in the boudnaries lie on the min and max x-values of domain\nprint(\"right:\",mesh.points[right_], \"\\n\\nleft:\",mesh.points[left_])\n</pre> ## identify the nodes along the right and left boundaries  right_ = np.where(mesh.points[:, 0] == 10)[0] left_ = np.where(mesh.points[:, 0] == 0)[0] top_ = np.where(mesh.points[:,1] == 1)[0] bottom_=np.where(mesh.points[:,1] == 0)[0]  ## Check that the coordinates of the nodes in the boudnaries lie on the min and max x-values of domain print(\"right:\",mesh.points[right_], \"\\n\\nleft:\",mesh.points[left_])  <pre>right: [[10.   0.   0. ]\n [10.   1.   0. ]\n [10.   0.5  0. ]] \n\nleft: [[0.  0.  0. ]\n [0.  1.  0. ]\n [0.  0.5 0. ]]\n</pre> In\u00a0[84]: Copied! <pre># Apply the boundary conditions\n\n## Apply temperature of 100  on left and 0 on the right\nfor node in right_:\n    # set the right hand side vector value\n    b[node] = 0.\n    # set the corresponding row in matrix A to identity\n    A_matrix[node,:] = 0\n    A_matrix[node, node] = 1.\n    \nfor node in left_:\n    # set the right hand side vector value\n    b[node] = 100.\n    # set the corresponding row in matrix A to identity\n    A_matrix[node,:] = 0\n    A_matrix[node, node] = 1.\n</pre> # Apply the boundary conditions  ## Apply temperature of 100  on left and 0 on the right for node in right_:     # set the right hand side vector value     b[node] = 0.     # set the corresponding row in matrix A to identity     A_matrix[node,:] = 0     A_matrix[node, node] = 1.      for node in left_:     # set the right hand side vector value     b[node] = 100.     # set the corresponding row in matrix A to identity     A_matrix[node,:] = 0     A_matrix[node, node] = 1.  <p>Finally solve the linear system of equations for solution vector $x$.</p> In\u00a0[85]: Copied! <pre>## solve the linear systme of equations\nx = np.linalg.solve(A_matrix, b)\n</pre> ## solve the linear systme of equations x = np.linalg.solve(A_matrix, b)  <p>After solving for $x$ we analyse the results. In this exercise, we expect the temperature to vary linearly from the left to the right boundary. To visualise this, we can plot the nodes on a map and color them based on the temperatures in the solution vector. This provides a quick and effective way to verify the expected linear relationship, which we can see from the plot below.</p> In\u00a0[86]: Copied! <pre>plt.figure(figsize=(12, 4))  \nplt.scatter(points[:, 0], points[:, 1], c=x, cmap='hot', s=50)\nplt.colorbar(label=\"Temperature\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.title(\"2D Temperature Distribution\")\nplt.show()\n</pre> plt.figure(figsize=(12, 4))   plt.scatter(points[:, 0], points[:, 1], c=x, cmap='hot', s=50) plt.colorbar(label=\"Temperature\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.title(\"2D Temperature Distribution\") plt.show() In\u00a0[15]: Copied! <pre>from FEM_Module.Support_functions import write_vtk\n\nwrite_vtk(2,mesh, x, 2,\"temperature\", \"scalar\",\"final_temp_solution\")\n</pre> from FEM_Module.Support_functions import write_vtk  write_vtk(2,mesh, x, 2,\"temperature\", \"scalar\",\"final_temp_solution\") In\u00a0[87]: Copied! <pre>## Solution to the connectivity matrix \nquad_mesh_connectivity=np.array([[0,1,7,6],[1,2,8,7],[2,3,9,8],[3,4,10,9],[4,5,11,10]])\n\n# This corresponds to the following points\nquad_mesh_points = np.array([[0.,0.],[2.,0.,],[4.,0.],[6.,0.,],[8.,0.],[10.,0.],\n                          [0.,1.],[2.,1.,],[4.,1.],[6.,1.,],[8.,1.],[10.,1.]])\n</pre>  ## Solution to the connectivity matrix  quad_mesh_connectivity=np.array([[0,1,7,6],[1,2,8,7],[2,3,9,8],[3,4,10,9],[4,5,11,10]])  # This corresponds to the following points quad_mesh_points = np.array([[0.,0.],[2.,0.,],[4.,0.],[6.,0.,],[8.,0.],[10.,0.],                           [0.,1.],[2.,1.,],[4.,1.],[6.,1.,],[8.,1.],[10.,1.]]) In\u00a0[88]: Copied! <pre>## Solution to the basis functions exercise\n### the local r axis is along x dimension and s is along the y dimension\n                \n### Derivatives of the linear quadrilateral element\ndef basis_fn_quad_linear_der_dNr(degree,point):\n    # Derivative of basis functions with respect to r\n    r = point[0]\n    s = point[1]\n    \n\n    dNr = np.zeros((4,)) \n    dNr[0] = -0.25 * (1. - s)\n    dNr[1] = 0.25 * (1. - s)\n    dNr[2] = 0.25 * (1 + s)\n    dNr[3] = -0.25 * ( 1 + s)\n        \n    return dNr\n        \ndef basis_fn_quad_linear_der_dNs(degree,point):\n    # Derivative of basis functions with respect to s\n    r = point[0]\n    s = point[1]\n    \n    dNs = np.zeros((4,)) ## for each basis function\n    ## Corner nodes first\n    dNs[0] = -0.25 * ( 1 - r)\n    dNs[1] = -0.25 * ( 1 + r)\n    dNs[2] = 0.25 * (1 + r)\n    dNs[3] = 0.25 * ( 1 - r)\n\n    return dNs\n        \n               \n\ndef basis_fn_quad_linear_der(degree, point):\n    ## Givent the coordinate of the point in the local coordinate system (r,s)\n    ## we evaulate the basis functions at that point \n    \n    ## linear elements\n    dNr = basis_fn_quad_linear_der_dNr(1,point)\n    dNs = basis_fn_quad_linear_der_dNs(1,point)\n       \n    basis_functions = np.vstack((dNr,dNs)) \n        \n    return basis_functions\n</pre> ## Solution to the basis functions exercise ### the local r axis is along x dimension and s is along the y dimension                  ### Derivatives of the linear quadrilateral element def basis_fn_quad_linear_der_dNr(degree,point):     # Derivative of basis functions with respect to r     r = point[0]     s = point[1]           dNr = np.zeros((4,))      dNr[0] = -0.25 * (1. - s)     dNr[1] = 0.25 * (1. - s)     dNr[2] = 0.25 * (1 + s)     dNr[3] = -0.25 * ( 1 + s)              return dNr          def basis_fn_quad_linear_der_dNs(degree,point):     # Derivative of basis functions with respect to s     r = point[0]     s = point[1]          dNs = np.zeros((4,)) ## for each basis function     ## Corner nodes first     dNs[0] = -0.25 * ( 1 - r)     dNs[1] = -0.25 * ( 1 + r)     dNs[2] = 0.25 * (1 + r)     dNs[3] = 0.25 * ( 1 - r)      return dNs                           def basis_fn_quad_linear_der(degree, point):     ## Givent the coordinate of the point in the local coordinate system (r,s)     ## we evaulate the basis functions at that point           ## linear elements     dNr = basis_fn_quad_linear_der_dNr(1,point)     dNs = basis_fn_quad_linear_der_dNs(1,point)             basis_functions = np.vstack((dNr,dNs))               return basis_functions In\u00a0[89]: Copied! <pre>quad_integration_points =[[-1./np.sqrt(3),-1/np.sqrt(3)],\n                          [-1/np.sqrt(3),1/np.sqrt(3)],\n                          [1/np.sqrt(3),-1/np.sqrt(3)],\n                          [1/np.sqrt(3),1/np.sqrt(3)]]\n\nquad_integration_weights=[1.,1.,1.,1.]\n\ndef jacobian_quad(degree, point, e_nodes):\n    #e_nodes is numpy array (num_nodes, 2) of all the global coordinates of the nodes\n    space_dim = 2 ## for now we assume dimension is 2\n    \n    ## in this case we are mapping 2D space to 2D so Jacobian is a square\n    Jacobian_mat = np.zeros((space_dim,space_dim))\n    \n    dnr = basis_fn_quad_linear_der_dNr(degree, point)\n    dns = basis_fn_quad_linear_der_dNs(degree, point)\n\n    for dim in range(2):\n        Jacobian_mat[0,dim] =np.dot(dnr, e_nodes[:,dim])# x coordinate\n        Jacobian_mat[1,dim] =np.dot(dns, e_nodes[:,dim])# y coordinate\n    \n    det = np.linalg.det(Jacobian_mat)\n    return det, Jacobian_mat\n        \n    \n</pre> quad_integration_points =[[-1./np.sqrt(3),-1/np.sqrt(3)],                           [-1/np.sqrt(3),1/np.sqrt(3)],                           [1/np.sqrt(3),-1/np.sqrt(3)],                           [1/np.sqrt(3),1/np.sqrt(3)]]  quad_integration_weights=[1.,1.,1.,1.]  def jacobian_quad(degree, point, e_nodes):     #e_nodes is numpy array (num_nodes, 2) of all the global coordinates of the nodes     space_dim = 2 ## for now we assume dimension is 2          ## in this case we are mapping 2D space to 2D so Jacobian is a square     Jacobian_mat = np.zeros((space_dim,space_dim))          dnr = basis_fn_quad_linear_der_dNr(degree, point)     dns = basis_fn_quad_linear_der_dNs(degree, point)      for dim in range(2):         Jacobian_mat[0,dim] =np.dot(dnr, e_nodes[:,dim])# x coordinate         Jacobian_mat[1,dim] =np.dot(dns, e_nodes[:,dim])# y coordinate          det = np.linalg.det(Jacobian_mat)     return det, Jacobian_mat                In\u00a0[90]: Copied! <pre>num_nodes = len(rectangular_mesh_points) #*** total number of nodes \n\n# Set up the empty linear system of equations\nA_matrix = np.zeros((num_nodes, num_nodes))\nb = np.zeros((num_nodes,))\n\n## Iterate through each element in the mesh \nfor element_ID, element in enumerate(rectangular_mesh_connectivity):\n    \n    # ***  get the list of integration points and the list of global IDs for nodes in the element\n    IntegrationPoints, IP_weights = quad_integration_points,quad_integration_weights\n    # *** \n    e_nodes_xy = rectangular_mesh_points[element]\n    \n   \n    ## we first get the local stiffness matrix for the element by accumulating\n    ## over all the integration points\n    LHS = np.zeros((len(element), len(element)))\n    for IP, weight in zip(IntegrationPoints,IP_weights):\n        B = basis_fn_quad_linear_der(degree, IP)\n        BT = B.transpose() * MatrixThermalConduct\n        BT = np.matmul(BT, B)\n        detJ, _ = jacobian_quad(degree, IP, e_nodes_xy) # *** using updated jacobian matrix \n        BT = BT * weight*(detJ) \n        LHS += BT # this is a element level stiffness matrix\n        \n    ## once LHS has been accumulated over all the integration points, we add it to the global matrix A_matrix\n    ## this uses the global node IDs to determine which indices are updates\n    for i in range(len(element)):\n        for j in range(len(element)):\n            col = int(element[i])\n            row = int(element[j])\n            A_matrix[row][col]+= LHS[int(j)][int(i)]\n</pre> num_nodes = len(rectangular_mesh_points) #*** total number of nodes   # Set up the empty linear system of equations A_matrix = np.zeros((num_nodes, num_nodes)) b = np.zeros((num_nodes,))  ## Iterate through each element in the mesh  for element_ID, element in enumerate(rectangular_mesh_connectivity):          # ***  get the list of integration points and the list of global IDs for nodes in the element     IntegrationPoints, IP_weights = quad_integration_points,quad_integration_weights     # ***      e_nodes_xy = rectangular_mesh_points[element]              ## we first get the local stiffness matrix for the element by accumulating     ## over all the integration points     LHS = np.zeros((len(element), len(element)))     for IP, weight in zip(IntegrationPoints,IP_weights):         B = basis_fn_quad_linear_der(degree, IP)         BT = B.transpose() * MatrixThermalConduct         BT = np.matmul(BT, B)         detJ, _ = jacobian_quad(degree, IP, e_nodes_xy) # *** using updated jacobian matrix          BT = BT * weight*(detJ)          LHS += BT # this is a element level stiffness matrix              ## once LHS has been accumulated over all the integration points, we add it to the global matrix A_matrix     ## this uses the global node IDs to determine which indices are updates     for i in range(len(element)):         for j in range(len(element)):             col = int(element[i])             row = int(element[j])             A_matrix[row][col]+= LHS[int(j)][int(i)]  In\u00a0[91]: Copied! <pre>          \n#Step 5. Apply the boundary conditions\n\n## Apply temperature of 0 on the right\nfor node in [5,11]:\n    # set the right hand side vector value\n    b[node] = 0.\n    # set the corresponding row in matrix A to identity\n    A_matrix[node,:] = 0\n    A_matrix[node, node] = 1.\n    \n    \n## Apply temperature of 100 on the left\nfor node in [0,6]:\n    # set the right hand side vector value\n    b[node] = 100.\n    # set the corresponding row in matrix A to identity\n    A_matrix[node,:] = 0\n    A_matrix[node, node] = 1.\n\n    ## solve the linear systme of equations\nx = np.linalg.solve(A_matrix, b)\n</pre>            #Step 5. Apply the boundary conditions  ## Apply temperature of 0 on the right for node in [5,11]:     # set the right hand side vector value     b[node] = 0.     # set the corresponding row in matrix A to identity     A_matrix[node,:] = 0     A_matrix[node, node] = 1.           ## Apply temperature of 100 on the left for node in [0,6]:     # set the right hand side vector value     b[node] = 100.     # set the corresponding row in matrix A to identity     A_matrix[node,:] = 0     A_matrix[node, node] = 1.      ## solve the linear systme of equations x = np.linalg.solve(A_matrix, b)  In\u00a0[92]: Copied! <pre>plt.figure(figsize=(12, 4))  \nplt.scatter(rectangular_mesh_points[:, 0], rectangular_mesh_points[:, 1], c=x, cmap='hot', s=50)\nplt.colorbar(label=\"Temperature\")\nplt.xlabel(\"X\")\nplt.ylabel(\"Y\")\nplt.title(\"2D Temperature Distribution\")\nplt.show()\n</pre> plt.figure(figsize=(12, 4))   plt.scatter(rectangular_mesh_points[:, 0], rectangular_mesh_points[:, 1], c=x, cmap='hot', s=50) plt.colorbar(label=\"Temperature\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.title(\"2D Temperature Distribution\") plt.show() In\u00a0[93]: Copied! <pre>plt.plot(rectangular_mesh_points[:6][:, 0], x[:6], \"x\", label=(\"bottom nodes\"), markersize=12)\nplt.plot(rectangular_mesh_points[6:][:, 0],x[6:], \"o\", label=(\"top nodes\"))\nplt.legend()\n</pre> plt.plot(rectangular_mesh_points[:6][:, 0], x[:6], \"x\", label=(\"bottom nodes\"), markersize=12) plt.plot(rectangular_mesh_points[6:][:, 0],x[6:], \"o\", label=(\"top nodes\")) plt.legend() Out[93]: <pre>&lt;matplotlib.legend.Legend at 0x21e1ea76250&gt;</pre>"},{"location":"Part_1/#exercise-1","title":"Exercise 1\u00b6","text":""},{"location":"Part_1/#problem-description","title":"Problem Description\u00b6","text":"<p>When developing any code for numerical simulations it is best to start with a problem that has an analytical solution that we can use for code validation. The heat transfer in steady-state conditions (i.e. not time dependent) is one of the simplest examples to solve. Given a problem domain we apply heat source of temperature $T_2$ to one side of the domain while keeping the temperature on the other side at a constant temperature $T_1$.</p> <p>The change in the temperature throughout the domain is described by the second order heat equation</p> <p>$$\\frac{\\partial T}{\\partial t}= c^2 \\frac{\\partial ^2 T}{\\partial x^2},$$</p> <p>where $T$ is the temperature, $c$ is the thermal diffusivity of the domain and $x$ presents the physical location along the domain.</p> <p>This is a second-order differential equation in space ($x$) and first-order in time ($t$). However, at steady state, the temperature is time-invariant, so the $\\frac{\\partial T}{\\partial t}$ is $0$ and the equations simplifies to a second-order ordinary differential equation (ODE) in space:</p> <p>$$0= c^2 \\frac{\\partial T}{\\partial x},$$</p> <p>This differential equation can be easily solved analytically. The solution for temperature is a linear change in temperature along the bar. To demonstrate how FEM works we will solve this differential equation.</p> <p>It is important to note that Finite Element Method doesn't solve the exact differential equation, but instead works with its weak form. Differential equations can be expressed in two ways:</p> <ul> <li><p>Strong Form: This is the differential equation itself. When solved with the given boundary conditions, it provides the exact solution. However, solving the strong form can be challenging due to the strict mathematical requirements imposed on the solution.</p> </li> <li><p>Weak Form: This is derived by multiplying the differential equation by a test function (chosen to satisfy specific conditions) and integrating over the domain. While the weak form does not necessarily yield the exact solution, it ensures that the equation holds in an averaged sense across the domain, making it more tractable for numerical methods like FEM.</p> </li> </ul> <p>For a short tutorial on weak form solutions please refer to: https://www.youtube.com/watch?v=k4AoE-rJ6n8</p>"},{"location":"Part_1/#step-1-discretisation","title":"Step 1. Discretisation\u00b6","text":"<p>The problem domain is a bar of length 10 meters and height of 1 meter. The first step in the Finite Element Method (FEM) is to divide it into finite elements, a process known as meshing. While the distribution of stresses and forces within complex geometries may be difficult to determine directly, through meshing we can represent this complex domain as a collection of simple shapes, called elements. Within these elements, we can apply our understanding of material behaviour and governing equations to achieve accurate simulations.</p> <p>For simple geometries, such as rectangles, meshing can be done manually. However, for more complex domains with irregular shapes or curved edges, meshing becomes challenging. In regions with fine details, a higher level of refinement (i.e. smaller elements) is needed to accurately capture the geometry.</p> <p>In general, a finer mesh with smaller elements leads to a more accurate solution by reducing approximation errors. However, increasing the number of elements also enlarges the system of linear equations, requiring more computational resources such as time and memory. Additionally, element quality plays a crucial role in numerical stability. Elements with a high aspect ratio, where one side is significantly longer than the others, can cause numerical instabilities and increase errors in the solution. Therefore, careful meshing is essential to balance accuracy, efficiency, and computational cost.</p> <p>Meshing is a major area of research, with significant effort dedicated to developing efficient and accurate techniques. Numerous software tools and packages, both free and commercial, are available for meshing. These tools incorporate advanced, optimized algorithms to generate high-quality meshes for various applications.</p>"},{"location":"Part_1/#element-types","title":"Element Types\u00b6","text":"<p>There are two key elements properties to consider: shape and order. The first is generally guided by the domain properties, while the second is by the differential equations.</p>"},{"location":"Part_1/#element-shape","title":"Element Shape\u00b6","text":"<p>Two most popular elements types for $2D$ are triangles and quadrilaterals. Below are two examples of splitting the same domain with triangles and with quadrilaterals.</p> <p>The element shape is usually determined by the problem domain. Quadrilaterals are better suited for regular domains with structured meshes, while triangles are better suited for irregular or curved domains. Therefore triangles are generally the preferred element type.</p>"},{"location":"Part_1/#element-order","title":"Element Order\u00b6","text":"<p>It is important to choose the correct element order for the system, as it can impact the quality of the solution. Each element is associated with a certain number of nodes and each node is a degree of freedom for the solution. Each node is also associated with a basis function that is used to describe the solution (see next section). Therefore higher order elements provide more degrees of freedom and can better describe complex behaviour of solution.</p>"},{"location":"Part_1/#key-take-aways","title":"Key Take Aways:\u00b6","text":"<ul> <li>Higher refinement and higher element order lead to lower approximation error in solution but higher computational costs.</li> <li>Triangular elements are most common element types</li> <li>Quadratic or linear elements should be sufficient for many problems.</li> <li>Numerical simulations are about finding the right balance in computation costs and solution accuracy.</li> </ul>"},{"location":"Part_1/#exercise","title":"Exercise\u00b6","text":"<p>For this code we will use a python package called <code>pygmsh</code>. By specifying the domain boundaries we can automatically mesh the domain. In the code below specify the boundaries of the domain and elements degree. By plotting the elements and nodes we can visualise the mesh.</p> <ul> <li>Try changing the domain boundaries and the degree to see how the mesh will change.</li> </ul> <p>Mesh is an object that contains the information about all the elements, nodes and their coordinates on the domain. Each node had a unique ID associated with it, that we will make use in later sections. <code>mesh.points</code> is the list of coordinates for all the nodes in the mesh.</p> <ul> <li>Use length of <code>mesh.points</code> to find out the number of nodes in the mesh. Try changing the element degree or the element size and see how that changes the number of nodes.</li> </ul>"},{"location":"Part_1/#step-2-key-element-functions","title":"Step 2. Key Element Functions\u00b6","text":""},{"location":"Part_1/#basis-functions","title":"Basis Functions\u00b6","text":"<p>After subdividing the domain into smaller elements, we approximate the solution $T$ to the differential equation within each element. This is done by expressing the solution in terms of basis functions $\\phi$,  such that the approximation of $T$ at any point $x$ is given by a linear combination of these basis functions and a set of coefficients $c_i$ $$T(x) = \\sum_{i=1}^nc_i \\phi_i,$$</p> <p>where $n$ is the number of nodes in the element, and $c_i$ represents the solution values at those nodes. The primary objective of the Finite Element Method (FEM) is to determine these coefficients, allowing interpolation of the solution throughout the domain.</p> <p>The basis functions $\\phi_i$ define how the solution varies within each element and depend on the type of elements used in the mesh. There are a variety of basis functions that can be used, provided they meet specific mathematical criteria. Among them, polynomial functions are the most commonly used, as they are both computationally efficient and sufficient for most applications.</p>"},{"location":"Part_1/#implementation-note","title":"Implementation Note:\u00b6","text":"<p>Note the order of the nodes and the basis functions. It is standard practice to number the corner nodes first and then the mid-side nodes in clockwise or counter-clockwise order. It is important to be consistent for all triangles in the mesh. For <code>pygmsh</code> library that we are using here, the nodes are ordered in counter-clockwise and use standard convention of corner nodes first and them mid-side, so we will follow the same order here for basis functions.</p> <p>For additional information on elements and basis functions please refer to https://www.geophysik.uni-muenchen.de/~igel/Lectures/NMG/08_finite_elements_basisfunctions.pdf</p>"},{"location":"Part_1/#exercise","title":"Exercise\u00b6","text":"<p>The basis functions for linear and quadratic triangle elements have been implemented below. You can view the basis function for each node by specifying up to three nodes in the <code>show_basis_fn</code> below and calling a function <code>visualise_basis_fn()</code> from file <code>Support_functions</code></p>"},{"location":"Part_1/#basis-functions-derivatives","title":"Basis Functions Derivatives\u00b6","text":"<p>In many differential equations, we often require the derivatives of the basis functions rather than the functions themselves. For two dimensional space there are two partial derivatives, one with respect to each axis, which are</p> <p>$$\\frac{\\partial }{\\partial r},\\frac{\\partial}{\\partial s}$$</p> <p>If the basis functions at a specific point are represented as a vector that contains the values of all the basis functions, then their derivatives for a matrix of dimension $[m,n]$, where $m$ is the spatial dimension (in this case two) and $n$ is the number of nodes in the element (i.e. the number of basis functions). This matrix is often referred to be $B$:</p> <p>$$B= \\begin{bmatrix} \\frac{\\partial{\\phi_0}}{\\partial r} &amp; \\cdots &amp; \\frac{\\partial{\\phi_5}}{\\partial r} \\\\ \\frac{\\partial{\\phi_0}}{\\partial s}  &amp; \\cdots &amp; \\frac{\\partial{\\phi_5}}{\\partial s} \\end{bmatrix} $$ where $\\phi_0 \\cdots \\phi_5$ are the basis functions and $r$ and $s$ are the dimension axis.</p>"},{"location":"Part_1/#exercise","title":"Exercise\u00b6","text":"<p>For the quadratic triangle the matrix the derivative matrix $B$ is of size $2x6$. Based on the equations in $(1)$ calculate the second row derivatives, i.e. $\\frac{\\partial}{\\partial s}$ and complete the function below instead of <code>...</code>. The derivative $\\frac{\\partial}{\\partial r}$ is given below and implemented as example.</p> <p>$$B= \\begin{bmatrix} -3 +4r+4s &amp; -1+4r &amp; 0 &amp; 4-8r-4s &amp; 4s &amp; -4s\\\\ . .. &amp; ...&amp; ...&amp; ... &amp;... &amp;... \\end{bmatrix} $$</p> <p>Note: The solution to this exercise can be found in hidden cell marked \"Solution\". Double click on the cell to open it.</p>"},{"location":"Part_1/#exercise","title":"Exercise\u00b6","text":"<p>Calculate the basis functions and their derivatives for a quadrilateral two dimensional linear element in coordinate system $(r,s)$ and implement them below. The element boundaries are at $[-1,1]$x$[-1,1]$.</p> <p>Reminder that the basis function must satisfy the mathematical properties: compact support, interpolation property and partition of unity.</p>"},{"location":"Part_1/#hint","title":"Hint:\u00b6","text":"<p>For quadrilateral linear element there are four basis functions. The basis function for node $0$ is given provided, you can use its structure to find the other basis functions and fill in the missing parts instead of <code>...</code>.</p> <p>Once you know the basis functions, it is easy to find the derivatives by differentiating each basis function with respect to r or s.</p> <p>Note: The solution to this exercise can be found in hidden cell marked \"Solution\". Double click on the cell to open it.</p>"},{"location":"Part_1/#derivatives-of-the-linear-quadrilateral-element","title":"Derivatives of the linear quadrilateral element\u00b6","text":"<p>def basis_fn_quad_linear_der_dNr(degree,point): # Derivative of basis functions with respect to r r = point[0] s = point[1]</p> <pre><code>dNr = np.zeros((4,)) \ndNr[0] = -0.25 * (1. - s)\ndNr[1] = 0.25 * (1. - s)\ndNr[2] = 0.25 * (1 + s)\ndNr[3] = -0.25 * ( 1 + s)\n    \nreturn dNr\n    </code></pre> <p>def basis_fn_quad_linear_der_dNs(degree,point): # Derivative of basis functions with respect to s r = point[0] s = point[1]</p> <pre><code>dNs = np.zeros((4,)) ## for each basis function\n## Corner nodes first\ndNs[0] = -0.25 * ( 1 - r)\ndNs[1] = -0.25 * ( 1 + r)\ndNs[2] = 0.25 * (1 + r)\ndNs[3] = 0.25 * ( 1 - r)\n\nreturn dNs\n    \n           </code></pre> <p>def basis_fn_quad_linear_der(degree, point): ## Givent the coordinate of the point in the local coordinate system (r,s) ## we evaulate the basis functions at that point</p> <pre><code>## linear elements\nif degree == 1:\n    dNr = basis_fn_quad_linear_der_dNr(1,point)\n    dNs = basis_fn_quad_linear_der_dNs(1,point)\n   \n    basis_functions = np.vstack((dNr,dNs)) \n    \nreturn basis_functions\n\n```</code></pre>"},{"location":"Part_1/#jacobian-matirx","title":"Jacobian Matirx\u00b6","text":"<p>It is important to note that the basis functions discussed above are defined for specific unit triangles and quadrilaterals that use a local coordinate system. These elements, known as isoparametric elements, are structured to have regular shapes with right angles, such as squares and right-angled triangles. In these elements, the basis functions derived from the element geometry are also used to describe the solution field.</p> <p>Isoparametric elements are particularly useful when working with unstructured meshes, where the elements may vary in size and shape, unlike the uniform triangular mesh described earlier. In such cases, each irregular element in the global coordinate system $(x,y)$ can be mapped to a reference isoparametric element in the local coordinate system $(r,s)$, allowing the same basis functions to be applied consistently across all elements.</p> <p>This mapping allows for more consistent and easier implementation in software. During the mapping process the area and orientation of the triangle may change and that transformation of the element is summarised in Jacobian matrix.</p> <p>$$ \\begin{equation} \\it{J} =  \\begin{bmatrix} \\frac{\\partial{x}}{\\partial r} &amp; \\frac{\\partial{y}}{\\partial r} \\\\ \\frac{\\partial{x}}{\\partial s} &amp; \\frac{\\partial{y}}{\\partial s} \\\\ \\end{bmatrix} \\end{equation} $$</p> <p>where $\\phi$ are the basis functions and $i$ is ID of corresponding node. The determinant of the matrix represents the change and orientation in the triangle area. By multiplying the basis functions by the Jacobian we can map the isoparametric basis functions to the global basis functions of the original element.</p> <p>To calculate the Jacobian matrix we multiply the derivatives of the basis functions by the global coordinates of the corresponding nodes:</p> <p>$$ \\begin{equation} \\it{J} =  \\begin{bmatrix} \\sum\\frac{\\partial{\\phi_i}}{\\partial r}x_i &amp; \\sum\\frac{\\partial{\\phi_i}}{\\partial r}y_i \\\\ \\sum\\frac{\\partial{\\phi_i}}{\\partial s}x_i &amp; \\sum\\frac{\\partial{\\phi_i}}{\\partial s}y_i \\\\ \\end{bmatrix} \\end{equation} $$</p> <p>The calculation of the Jacobian matrix is implemented in the function below. The size of the Jacobian matrix depends on the dimensions of the local and global coordinate systems. In our case both coordinate systems are two dimensional therefore the Jacobian is $2x2$ matrix.</p> <p>Note: for interested reader please refer here for more details: https://www.khanacademy.org/math/multivariable-calculus/multivariable-derivatives/jacobian/v/the-jacobian-matrix</p>"},{"location":"Part_1/#step-3-matrix-assembly","title":"Step 3. Matrix Assembly\u00b6","text":"<p>The next step in Finite Element Method is accumulation into the linear system of equations. As mentioned previously we iterate over each element and calculate the element stiffness matrix $K^e$ that is derived from the weak form of the governing equations.</p> <p>$$K^e=\\int_{\\Omega^e}B^Tc^2 B d\\Omega,$$</p> <p>where $\\Omega^e$ is the element domain, $B$ is a matrix of basis function derivatives and $c$ is the thermal diffusivity.</p>"},{"location":"Part_1/#integration","title":"Integration\u00b6","text":"<p>Part of the weak form solution is to perform integration of the governing differential equations over each element domain. To perform numerical integration we use Gaussian Quadrature. This approximates the integral of a function over a domain as a weighted sum of the function $f$ evaluated at specific points. $$\\int_{\\Omega^e} f(x) dx \\approx \\sum_{j=1}^m w_jf(x_j),$$ where $x_j$ are the specific Gaussian points of integration, $w_j$ are the corresponding weights and $m$ is the total number of Gaussian points.</p> <p>The Gaussian points are specific for the different domain shapes and the degree of the function $f$. For isoparametric triangle of degree $2$ we should use at least three integration points. Using too few integration points will lead to inaccurate integration and subsequently the solution. Using too many integration points will not improve the solution, but will impact the computational time, since for each element we have to iterate over each integration point.</p> <p>For unit triangles of degree two or less then integration points are implemented below.</p> <p>For more information on Gaussian Quadrature please watch: https://www.youtube.com/watch?v=Hu6yqs0R7GA</p>"},{"location":"Part_1/#local-and-global-node-ids","title":"Local and Global Node IDs\u00b6","text":"<p>Final step in accumulation of linear system of equations is deriving the connectivity matrix. As we iterate over each element the basis functions and the element stiffness matrix use local node IDs, which are the same across all elements. To correctly identify the solution at each node, the nodes are also given global node IDs. The connectivity matrix is a list of arrays, where each row stores the global node IDs for an element. The connectivity row for the element below is <code>[0 21 44 63 17 3]</code>, since it follows the order of the local IDs (in red)</p>"},{"location":"Part_1/#exercise","title":"Exercise\u00b6","text":"<p>Construct the connectivity matrix for the following mesh and fill in the array below instead of <code>...</code>. </p> <p>Note: The solution to this exercise can be found in hidden cell marked \"Solution\". Double click on the cell to open it.</p>"},{"location":"Part_1/#accumulation","title":"Accumulation\u00b6","text":"<p>For this step we perform the accumulation of the linear system of equations of the form $Ax=b$. Where A is the matrix of size [n,n], where $n$ is the number of nodes in the system. Each row corresponds to the node with that ID and the column entries in that row will only be non-zero if the nodes are connected.</p>"},{"location":"Part_1/#step-4-boundary-conditions","title":"Step 4. Boundary Conditions\u00b6","text":"<p>There are two primary types of boundary conditions: Dirichlet and Neumann. Dirichlet boundary conditions specify the exact value of the solution at certain points, while Neumann boundary conditions define the value of the solution's derivative. These boundary conditions contribute to the right-hand side vector $b$ in the system of equations.</p> <p>In this exercise, we apply Dirichlet boundary conditions because a heat source maintains the temperature at $10^\\circ C$ along the left boundary, while a cooling source keeps the right boundary at $0^\\circ C$. To enforce this, we assign a value of $10$ in the vector $b$ at the indices corresponding to the nodes on the left boundary. Additionally, the corresponding rows in the matrix $A$ are modified by setting all elements to zero except for $1$ along the diagonal. We repeat the same for the right boundary nodes, except the right-hand side vector $b$ remains at zero. This ensures that the solution vector $x$ correctly reflects the prescribed temperatures at those boundaries.</p> <p>To identify the nodes on the left and right boundaries, we note that their $x$-coordinates correspond to the $x$-limits of the bar: $0$ and $10$, respectively. We can use the <code>points</code> list of the <code>mesh</code> object (this contains list of global coordinates of all the nodes) to identify these nodes.</p>"},{"location":"Part_1/#step-5-solution-visualisation","title":"Step 5. Solution Visualisation\u00b6","text":""},{"location":"Part_1/#vtk-file","title":"VTK file\u00b6","text":"<p>A widely used tool for visualising results is ParaView, which offers a range of powerful capabilities for data analysis, including viewing the model in detail in $3D$. It supports the <code>vtk</code> and <code>vtu</code> file formats, which store both mesh information and solution values at the nodes. The following function generates a <code>vtk</code> file containing the mesh and solution data. When this file is opened in ParaView, linear interpolation is applied within the elements for visualization.</p> <p>It is also possible to view the <code>vtk</code> files online without downloading Paraview. The file can be uploaded to the following website, which provides a limited version of Paraview:</p> <p>https://kitware.github.io/glance/app/</p>"},{"location":"Part_1/#exercise-linear-quadrilateral-elements","title":"Exercise: Linear Quadrilateral Elements\u00b6","text":"<p>So far, we've been working with quadratic triangular elements. However, we can also solve the same problem using linear rectangular elements. By combining the results and methods from the previous exercises, we now have everything we need to set up and run the example using linear rectangles instead.</p> <p>Using the mesh we defined before:</p>"},{"location":"Part_1/#step-1-mesh-construction","title":"Step 1. Mesh Construction\u00b6","text":"<p>Below are solutions from mesh connectivity matrix</p>"},{"location":"Part_1/#step-2-basis-functions","title":"Step 2. Basis functions\u00b6","text":"<p>Below are the solution functions for the derivatives of basis functions</p>"},{"location":"Part_1/#step-3-matrix-accumulation","title":"Step 3. Matrix Accumulation\u00b6","text":"<p>For linear quadrilateral we need to use different integration points and weights. The isoparametric quadrilateral elements is of dimension [-1,1] in r direction and [1,1] in s direction. We will also adjust the Jacobian function to use the relevant basis functions.</p> <p>Then we put it all together and highlighted with <code>**</code> the parts we updated</p>"},{"location":"Part_1/#step-4-boundary-conditions","title":"Step 4. Boundary Conditions\u00b6","text":"<p>For this mesh there are only two points on the right and left boundaries: nodes 5 and 11 for right boundary, and nodes 0 and 6 for left boundary</p>"},{"location":"Part_1/#step-5-solution-visualisation","title":"Step 5. Solution Visualisation\u00b6","text":"<p>We can plot the solution as before and use the solution <code>x</code> as colour. For this case we can also plot the value along the top and bottom values directly.</p> <p>From the graphs below we can see that the solutions are linear along the domain as expected. So for this problem using quadrilateral elements or triangles and of different degrees had no impact on solution. However, for more complex problems it could make a difference as explained in section 1 \"Discretisation\".</p>"},{"location":"Part_1/#exercise-1-ends","title":"Exercise 1 ends.\u00b6","text":""},{"location":"Part_2/","title":"Part 2","text":"<p>This exercise builds on the concepts of Finite Element Method that were introduced in Exercise 1. We will focus on solving a more complex problem, where the solution is a vector fields (instead of scalar) and we apply a combination of two different types of boundary conditions.</p> In\u00a0[10]: Copied! <pre>import sys\nsys.path += [\".\", \"..\"]\nfrom FEM_Module.FEM_Module_class import FEM_model\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport os\n\nfrom matplotlib.tri import Triangulation\n</pre> import sys sys.path += [\".\", \"..\"] from FEM_Module.FEM_Module_class import FEM_model  import matplotlib.pyplot as plt import numpy as np import os  from matplotlib.tri import Triangulation In\u00a0[\u00a0]: Copied! <pre># ------------ User Input required --------------------#\n## Domain Definition ##\nx_start = ...\nx_end = ...\ny_start = ...\ny_end = ...\ndomain_dim = ... \n\n\n### Input Element Type \nelement_degree = ... # specify the element order\nelement_length = ... # specify the domain refinement. Finer meshes lead to more accurate solution\n\n\n# ------------ End of User Input  --------------------#\n</pre> # ------------ User Input required --------------------# ## Domain Definition ## x_start = ... x_end = ... y_start = ... y_end = ... domain_dim = ...    ### Input Element Type  element_degree = ... # specify the element order element_length = ... # specify the domain refinement. Finer meshes lead to more accurate solution   # ------------ End of User Input  --------------------#  Solution.(*Hidden content here, visible but not collapsible on GitHub.*) In\u00a0[\u00a0]: Copied! <pre>###########SOLUTION\n########### The following inputs can be changed ################\n## Domain Definition ##\nx_start = 0\nx_end = 60\ny_start = -1.5\ny_end = 1.5\ndomain_dim = 2\n\n\n### Input Element Type \nelement_degree = 2 # specify the element order\nelement_length = 1 # specify the domain refinement. Finer meshes lead to more accurate solution\n</pre> ###########SOLUTION ########### The following inputs can be changed ################ ## Domain Definition ## x_start = 0 x_end = 60 y_start = -1.5 y_end = 1.5 domain_dim = 2   ### Input Element Type  element_degree = 2 # specify the element order element_length = 1 # specify the domain refinement. Finer meshes lead to more accurate solution   In\u00a0[\u00a0]: Copied! <pre># Initialing the FEM model\nFEM_ = FEM_model(domain_dim)\n\nL=x_end- x_start\nt=1\nc=(y_end-y_start)/2.\n\n## Create the domain name\nFEM_.domain_mesh(element_degree, element_length, [x_start,x_end], [y_start,y_end])\nprint(\"There are \", FEM_.num_nodes,\" nodes in the mesh\")\nFEM_.visualise_mesh()\n</pre> # Initialing the FEM model FEM_ = FEM_model(domain_dim)  L=x_end- x_start t=1 c=(y_end-y_start)/2.  ## Create the domain name FEM_.domain_mesh(element_degree, element_length, [x_start,x_end], [y_start,y_end]) print(\"There are \", FEM_.num_nodes,\" nodes in the mesh\") FEM_.visualise_mesh() <pre>There are  1091  nodes in the mesh\n</pre> In\u00a0[25]: Copied! <pre>## Set up the material properties:\n\nYoungs_modulus =1e6\nPoisson_ratio = 0.25\n\n## Set up empty matrix global matrix A and the right hand side vector b\n\nnum_nodes = len(FEM_.mesh.points)\nA_matrix = np.zeros((num_nodes*domain_dim, num_nodes*domain_dim)) ## note that for each node there are 2 d.o.f\nb = np.zeros((num_nodes*domain_dim,))\n\n## Now we iterate through each element in the mesh in the same way before\nfor element in FEM_.element_list_2D:\n    \n    # ------------ User Input required ------------------------------------------#\n    # -- Step 1. Set the integration points IP and their weights \n    IPs, IP_weights = ...\n\n    # -- Step 2. Create empty LHS matrix for the element stiffness matrix ------------#\n    # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\n    LHS = np.zeros((...\n                    \n    # -- Step 3. Set up for loop to iterate over each integration point ------------#\n    for IP, weight in ...:\n                    \n        # -- Step 4. Get the list of corner nodes in the element and calculate\n        # --------   the Jacobian matrix using function Jacobian in FEM_module\n        e_nodes_xy = ...\n        detJ, JMat = ...\n        \n        # -- Step 5. Calculate the derivative basis functions at the integration point \n        # --------   use the function basis_functions_der() and multiply it by the inverse of the Jacobian matrix\n        der_matrix = \n        der_matrix_JInv = \n        \n        # -- Step 6. Transform the derivative matrix into the B described above\n        # --------  use the function dN_To2DOF() in FEM_module\n        B = ...    \n        # -- Step 7. Take the transpose of the matrix B\n        BT = ..\n        # -- Step 8. Calculate matrix D. You can use the function stiffness_matrix_2D in FEM module\n        # --------   use the material properties Youngs_modulus and Poisson_ratio defined above\n        D = \n        \n        # -- Step 9. Multiply BT by D\n        \n        # -- Step 10. Multiply the matrix from Step 9 by B\n        \n        # -- Step 11. Multiply the final matrix by Jacobian determinant and weight of the integration point\n        \n        # -- Step 12. Add the resulting matrix to the element stiffness matrix LHS\n                    \n    # -- Step 13. Accumulate the element stiffness matrix LHS to global matrix A\n    # ----------  The accumulation of the first d.o.f for the node is given as a hint\n    for i in range(len(element)):\n        for j in range(len(element)):\n            col = int(element[i])\n            row = int(element[j])\n            A_matrix[row*domain_dim,col*domain_dim]+= LHS[int(j*domain_dim)][int(i*domain_dim)] # xx\n            A_matrix[row*domain_dim,col*domain_dim+1]+=...\n            A_matrix...\n            A_matrix...\n\n    # ------------ End of User Input ------------------------------------------#\n</pre> ## Set up the material properties:  Youngs_modulus =1e6 Poisson_ratio = 0.25  ## Set up empty matrix global matrix A and the right hand side vector b  num_nodes = len(FEM_.mesh.points) A_matrix = np.zeros((num_nodes*domain_dim, num_nodes*domain_dim)) ## note that for each node there are 2 d.o.f b = np.zeros((num_nodes*domain_dim,))  ## Now we iterate through each element in the mesh in the same way before for element in FEM_.element_list_2D:          # ------------ User Input required ------------------------------------------#     # -- Step 1. Set the integration points IP and their weights      IPs, IP_weights = ...      # -- Step 2. Create empty LHS matrix for the element stiffness matrix ------------#     # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f     LHS = np.zeros((...                          # -- Step 3. Set up for loop to iterate over each integration point ------------#     for IP, weight in ...:                              # -- Step 4. Get the list of corner nodes in the element and calculate         # --------   the Jacobian matrix using function Jacobian in FEM_module         e_nodes_xy = ...         detJ, JMat = ...                  # -- Step 5. Calculate the derivative basis functions at the integration point          # --------   use the function basis_functions_der() and multiply it by the inverse of the Jacobian matrix         der_matrix =          der_matrix_JInv =                   # -- Step 6. Transform the derivative matrix into the B described above         # --------  use the function dN_To2DOF() in FEM_module         B = ...             # -- Step 7. Take the transpose of the matrix B         BT = ..         # -- Step 8. Calculate matrix D. You can use the function stiffness_matrix_2D in FEM module         # --------   use the material properties Youngs_modulus and Poisson_ratio defined above         D =                   # -- Step 9. Multiply BT by D                  # -- Step 10. Multiply the matrix from Step 9 by B                  # -- Step 11. Multiply the final matrix by Jacobian determinant and weight of the integration point                  # -- Step 12. Add the resulting matrix to the element stiffness matrix LHS                          # -- Step 13. Accumulate the element stiffness matrix LHS to global matrix A     # ----------  The accumulation of the first d.o.f for the node is given as a hint     for i in range(len(element)):         for j in range(len(element)):             col = int(element[i])             row = int(element[j])             A_matrix[row*domain_dim,col*domain_dim]+= LHS[int(j*domain_dim)][int(i*domain_dim)] # xx             A_matrix[row*domain_dim,col*domain_dim+1]+=...             A_matrix...             A_matrix...      # ------------ End of User Input ------------------------------------------# <pre>\n  Cell In[25], line 21\n    LHS = np.zeros((...\n                   ^\nSyntaxError: '(' was never closed\n</pre> In\u00a0[16]: Copied! <pre>## Set up the material properties:\n\nYoungs_modulus =1e6\nPoisson_ratio = 0.25\n\n## Set up empty matrix global matrix A and the right hand side vector b\n\nnum_nodes = len(FEM_.mesh.points)\nA_matrix = np.zeros((num_nodes*domain_dim, num_nodes*domain_dim)) ## note that for each node there are 2 d.o.f\nb = np.zeros((num_nodes*domain_dim,))\n\n## Now we iterate through each element in the mesh in the same way before\nfor element in FEM_.element_list_2D:\n    \n    # ------------ User Input required ------------------------------------------#\n    # -- Step 1. Set the integration points IP and their weights \n    IPs, IP_weights = FEM_.integration_points()\n\n    # -- Step 2. Create empty LHS matrix for the element stiffness matrix ------------#\n    # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\n    LHS = np.zeros((len(element)*domain_dim, len(element)*domain_dim)) \n                    \n    # -- Step 3. Set up for loop to iterate over each integration point ------------#\n    for IP, weight in zip(IPs,IP_weights):\n                    \n        # -- Step 4. Get the list of corner nodes in the element and calculate\n        # --------   the Jacobian matrix using function Jacobian in FEM_module\n        e_nodes_xy = FEM_.global_node_coords[element][:,:3]\n        detJ, JMat = FEM_.jacobian(IP, e_nodes_xy)\n        \n        # -- Step 5. Calculate the derivative basis functions at the integration point \n        # --------   use the function basis_functions_der() and multiply it by the inverse of the Jacobian matrix\n        der_matrix = FEM_.basis_functions_der(IP)\n        der_matrix_JInv = np.matmul(np.linalg.inv(JMat), der_matrix)\n        \n        # -- Step 6. Transform the derivative matrix into the B described above\n        # --------  use the function dN_To2DOF() in FEM_module\n        B = FEM_.dN_To2DOF(der_matrix_JInv) \n        # -- Step 7. Take the transpose of the matrix B\n        BT =  B.transpose()\n        # -- Step 8. Calculate matrix D. You can use the function stiffness_matrix_2D in FEM module\n        # --------   use the material properties Youngs_modulus and Poisson_ratio defined above\n        D = FEM_.stiffness_matrix_2D(Youngs_modulus,Poisson_ratio)        \n        \n        # -- Step 9. Multiply BT by D\n        BT = np.matmul(BT, D)\n        # -- Step 10. Multiply the matrix from Step 9 by B\n        BT = np.matmul(BT, B)\n        # -- Step 11. Multiply the final matrix by Jacobian determinant and weight of the integration point\n        BT = BT * weight*(detJ) ## currently assume all the weight of IP are the same\n        # -- Step 12. Add the resulting matrix to the element stiffness matrix LHS\n        LHS += BT     \n    # -- Step 13. Accumulate the element stiffness matrix LHS to global matrix A\n    # ----------  The accumulation of the first d.o.f for the node is given as a hint\n    for i in range(len(element)):\n        for j in range(len(element)):\n            col = int(element[i])\n            row = int(element[j])\n            A_matrix[row*domain_dim,col*domain_dim]+= LHS[int(j*domain_dim)][int(i*domain_dim)] # xx\n            A_matrix[row*domain_dim,col*domain_dim+1]+= LHS[int(j*domain_dim)][int(i*domain_dim+1)] # xy\n            A_matrix[row*domain_dim+1,col*domain_dim]+= LHS[int(j*domain_dim+1)][int(i*domain_dim)] # y\n            A_matrix[row*domain_dim+1,col*domain_dim+1]+= LHS[int(j*domain_dim+1)][int(i*domain_dim+1)] # y\n\n            \n    # ------------ End of User Input ------------------------------------------#\n</pre> ## Set up the material properties:  Youngs_modulus =1e6 Poisson_ratio = 0.25  ## Set up empty matrix global matrix A and the right hand side vector b  num_nodes = len(FEM_.mesh.points) A_matrix = np.zeros((num_nodes*domain_dim, num_nodes*domain_dim)) ## note that for each node there are 2 d.o.f b = np.zeros((num_nodes*domain_dim,))  ## Now we iterate through each element in the mesh in the same way before for element in FEM_.element_list_2D:          # ------------ User Input required ------------------------------------------#     # -- Step 1. Set the integration points IP and their weights      IPs, IP_weights = FEM_.integration_points()      # -- Step 2. Create empty LHS matrix for the element stiffness matrix ------------#     # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f     LHS = np.zeros((len(element)*domain_dim, len(element)*domain_dim))                           # -- Step 3. Set up for loop to iterate over each integration point ------------#     for IP, weight in zip(IPs,IP_weights):                              # -- Step 4. Get the list of corner nodes in the element and calculate         # --------   the Jacobian matrix using function Jacobian in FEM_module         e_nodes_xy = FEM_.global_node_coords[element][:,:3]         detJ, JMat = FEM_.jacobian(IP, e_nodes_xy)                  # -- Step 5. Calculate the derivative basis functions at the integration point          # --------   use the function basis_functions_der() and multiply it by the inverse of the Jacobian matrix         der_matrix = FEM_.basis_functions_der(IP)         der_matrix_JInv = np.matmul(np.linalg.inv(JMat), der_matrix)                  # -- Step 6. Transform the derivative matrix into the B described above         # --------  use the function dN_To2DOF() in FEM_module         B = FEM_.dN_To2DOF(der_matrix_JInv)          # -- Step 7. Take the transpose of the matrix B         BT =  B.transpose()         # -- Step 8. Calculate matrix D. You can use the function stiffness_matrix_2D in FEM module         # --------   use the material properties Youngs_modulus and Poisson_ratio defined above         D = FEM_.stiffness_matrix_2D(Youngs_modulus,Poisson_ratio)                          # -- Step 9. Multiply BT by D         BT = np.matmul(BT, D)         # -- Step 10. Multiply the matrix from Step 9 by B         BT = np.matmul(BT, B)         # -- Step 11. Multiply the final matrix by Jacobian determinant and weight of the integration point         BT = BT * weight*(detJ) ## currently assume all the weight of IP are the same         # -- Step 12. Add the resulting matrix to the element stiffness matrix LHS         LHS += BT          # -- Step 13. Accumulate the element stiffness matrix LHS to global matrix A     # ----------  The accumulation of the first d.o.f for the node is given as a hint     for i in range(len(element)):         for j in range(len(element)):             col = int(element[i])             row = int(element[j])             A_matrix[row*domain_dim,col*domain_dim]+= LHS[int(j*domain_dim)][int(i*domain_dim)] # xx             A_matrix[row*domain_dim,col*domain_dim+1]+= LHS[int(j*domain_dim)][int(i*domain_dim+1)] # xy             A_matrix[row*domain_dim+1,col*domain_dim]+= LHS[int(j*domain_dim+1)][int(i*domain_dim)] # y             A_matrix[row*domain_dim+1,col*domain_dim+1]+= LHS[int(j*domain_dim+1)][int(i*domain_dim+1)] # y                   # ------------ End of User Input ------------------------------------------# Solution.(*Hidden content here, visible but not collapsible on GitHub.*)     Solution code. Copy from here &gt;     ```  <p>Youngs_modulus =1e6 Poisson_ratio = 0.25</p> In\u00a0[5]: Copied! <pre># ------------ User Input required ------------------------------------------#\nnodes_on_left_ =  ...\nnodes_on_right_ = ...\n\n# ------------ End of User Input ------------------------------------------#\n    \n# Find line elements that have all nodes the list of nodes_on_left_ boundary\nresult = np.all(np.isin(FEM_.mesh.cells_dict['line3'], nodes_on_left_), axis=1)\nelements_left_=FEM_.mesh.cells_dict['line3'][np.where(result)[0]]\n\n# Find line elements that have all nodes the list of nodes_on_left_ boundary\nresult = np.all(np.isin(FEM_.mesh.cells_dict['line3'], nodes_on_right_), axis=1)\nelements_right_=FEM_.mesh.cells_dict['line3'][np.where(result)[0]]\n\nprint(\"The list of elements on the left boundary are\\n\", elements_left_)\nprint(\"The list of elements on the right boundary are\\n\", elements_right_)\n</pre> # ------------ User Input required ------------------------------------------# nodes_on_left_ =  ... nodes_on_right_ = ...  # ------------ End of User Input ------------------------------------------#      # Find line elements that have all nodes the list of nodes_on_left_ boundary result = np.all(np.isin(FEM_.mesh.cells_dict['line3'], nodes_on_left_), axis=1) elements_left_=FEM_.mesh.cells_dict['line3'][np.where(result)[0]]  # Find line elements that have all nodes the list of nodes_on_left_ boundary result = np.all(np.isin(FEM_.mesh.cells_dict['line3'], nodes_on_right_), axis=1) elements_right_=FEM_.mesh.cells_dict['line3'][np.where(result)[0]]  print(\"The list of elements on the left boundary are\\n\", elements_left_) print(\"The list of elements on the right boundary are\\n\", elements_right_) <pre>\n  Cell In[5], line 2\n    nodes_on_left_ =\n                     ^\nSyntaxError: invalid syntax\n</pre> Solution.(*Hidden content here, visible but not collapsible on GitHub.*)     Solution code. Copy from here &gt;     ``` # ------------ User Input required ------------------------------------------# nodes_on_left_ = np.where(np.isclose(FEM_.mesh.points[:,0], x_start))[0] nodes_on_right_ =np.where(np.isclose(FEM_.mesh.points[:,0], x_end))[0]   In\u00a0[17]: Copied! <pre># ------------ User Input required ------------------------------------------#\nnodes_on_left_ = np.where(np.isclose(FEM_.mesh.points[:,0], x_start))[0]\nnodes_on_right_ =np.where(np.isclose(FEM_.mesh.points[:,0], x_end))[0]\n\n\n# ------------ End of User Input ------------------------------------------#\n    \n# Find line elements that have all nodes the list of nodes_on_left_ boundary\nif FEM_.degree == 1:\n    element_types = \"line\"\nelif FEM_.degree == 2:\n    element_types = \"line3\"\n    \nresult = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_left_), axis=1)\nelements_left_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]\n\n# Find line elements that have all nodes the list of nodes_on_left_ boundary\nresult = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_right_), axis=1)\nelements_right_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]\n\nprint(\"The list of elements on the left boundary are\\n\", elements_left_)\nprint(\"The list of elements on the right boundary are\\n\", elements_right_)\n</pre> # ------------ User Input required ------------------------------------------# nodes_on_left_ = np.where(np.isclose(FEM_.mesh.points[:,0], x_start))[0] nodes_on_right_ =np.where(np.isclose(FEM_.mesh.points[:,0], x_end))[0]   # ------------ End of User Input ------------------------------------------#      # Find line elements that have all nodes the list of nodes_on_left_ boundary if FEM_.degree == 1:     element_types = \"line\" elif FEM_.degree == 2:     element_types = \"line3\"      result = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_left_), axis=1) elements_left_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]  # Find line elements that have all nodes the list of nodes_on_left_ boundary result = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_right_), axis=1) elements_right_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]  print(\"The list of elements on the left boundary are\\n\", elements_left_) print(\"The list of elements on the right boundary are\\n\", elements_right_) <pre>The list of elements on the left boundary are\n [[  3 247 249]\n [247 248 250]\n [248   0 251]]\nThe list of elements on the right boundary are\n [[  1 123 125]\n [123 124 126]\n [124   2 127]]\n</pre> In\u00a0[18]: Copied! <pre>def basis_fun_line_quad(point):\n    r = point\n    N=np.zeros(3)\n    N[0] = 0.5*(r*r +r) \n    N[1] = 0.5*(r*r -r)\n    N[2] = 1-r*r\n    return N\n\ndef der_basis_fun_line_quad(point):\n    r = point\n    dN=np.zeros(3)\n    dN[0] = r+0.5\n    dN[1] = r-0.5\n    dN[2] = -2*r\n    return dN\n\n\ndef integration_points_1D():\n    IP_line = [-1/np.sqrt(3.),  1/np.sqrt(3.)]\n    IP_w = [1.,1.]\n    return IP_line, IP_w\n\n\ndef jacobian_1D(pt, element_xy_coord):\n    dN = der_basis_fun_line_quad(pt)\n    x_vals=element_xy_coord[:,1]\n    return np.dot(dN,x_vals )\n   \n</pre> def basis_fun_line_quad(point):     r = point     N=np.zeros(3)     N[0] = 0.5*(r*r +r)      N[1] = 0.5*(r*r -r)     N[2] = 1-r*r     return N  def der_basis_fun_line_quad(point):     r = point     dN=np.zeros(3)     dN[0] = r+0.5     dN[1] = r-0.5     dN[2] = -2*r     return dN   def integration_points_1D():     IP_line = [-1/np.sqrt(3.),  1/np.sqrt(3.)]     IP_w = [1.,1.]     return IP_line, IP_w   def jacobian_1D(pt, element_xy_coord):     dN = der_basis_fun_line_quad(pt)     x_vals=element_xy_coord[:,1]     return np.dot(dN,x_vals )     In\u00a0[19]: Copied! <pre># set force value\nP = 80\nb = np.zeros((num_nodes*domain_dim,))\n\n# Iterate through all the elements on the left boundary\nfor element in elements_left_: \n\n    # ------------ User Input required ------------------------------------------#\n    # -- Step 1. Set the integration points IP and their weights for 1D element\n    IPs, IP_weights = ...\n\n    # -- Step 2. Create empty RHS vector for element level force accumulation ------------#\n    # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\n    RHS = np.zeros((len(element)*domain_dim)) \n\n    # -- Step 3. Set up for loop to iterate over each integration point ------------#\n    for IP, weight in zip(IPs,IP_weights):\n\n        # take the y-coordinate of the middle node as the average of the element\n       # y_value_ = FEM_.mesh.points[element[2]][1] \n        y_value_ = ...\n        \n        # initialise the empty traction vector in x- and y-directions respectively\n        traction = [0,0]\n        # set the traction in the x-direction\n        traction[0]= ...\n         # calculate the traction in y-direction\n        traction[1] = ...\n\n        # -- Step 4. Get the list of corner nodes in the element and calculate\n        # --------   the Jacobian matrix in 1D using function Jacobian_1D\n        e_nodes_xy = FEM_.global_node_coords[element][:,:3]\n        detJ = ...\n        # -- Step 5. Calculate the basis functions of 1D element\n        N = ...\n        # -- Step 6. Create an empty vector for adjusted shape functions\n        Nnc = np.zeros(len(N)*domain_dim) \n        \n        # -- Step 7. Adjust the basis function vector for 2 d.o.f \n        # ---------   and multiply by the traction force in that direction\n        # iterate through all the nodes in element\n        for node_i in range(len(N)):\n            # for each node consider two degrees of freedom\n            for dof in range(domain_dim):  # for every dimension\n                    Nnc[node_i * 2 + dof] += ...\n        # -- Step 8. Multiply the vector by determinant and the integration point weight\n        Nnc = Nnc* weight * (detJ) \n        \n        # add to the RHS vector for accumulation\n        RHS+=Nnc\n        \n    # add the element level RHS vector to the global RHS vector b\n    for i in range(len(element)):\n        node = int(element[i])\n        b[node*domain_dim] += RHS[i*domain_dim]\n        b[node*domain_dim+1] += RHS[(i*domain_dim)+1]\n</pre> # set force value P = 80 b = np.zeros((num_nodes*domain_dim,))  # Iterate through all the elements on the left boundary for element in elements_left_:       # ------------ User Input required ------------------------------------------#     # -- Step 1. Set the integration points IP and their weights for 1D element     IPs, IP_weights = ...      # -- Step 2. Create empty RHS vector for element level force accumulation ------------#     # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f     RHS = np.zeros((len(element)*domain_dim))       # -- Step 3. Set up for loop to iterate over each integration point ------------#     for IP, weight in zip(IPs,IP_weights):          # take the y-coordinate of the middle node as the average of the element        # y_value_ = FEM_.mesh.points[element[2]][1]          y_value_ = ...                  # initialise the empty traction vector in x- and y-directions respectively         traction = [0,0]         # set the traction in the x-direction         traction[0]= ...          # calculate the traction in y-direction         traction[1] = ...          # -- Step 4. Get the list of corner nodes in the element and calculate         # --------   the Jacobian matrix in 1D using function Jacobian_1D         e_nodes_xy = FEM_.global_node_coords[element][:,:3]         detJ = ...         # -- Step 5. Calculate the basis functions of 1D element         N = ...         # -- Step 6. Create an empty vector for adjusted shape functions         Nnc = np.zeros(len(N)*domain_dim)                   # -- Step 7. Adjust the basis function vector for 2 d.o.f          # ---------   and multiply by the traction force in that direction         # iterate through all the nodes in element         for node_i in range(len(N)):             # for each node consider two degrees of freedom             for dof in range(domain_dim):  # for every dimension                     Nnc[node_i * 2 + dof] += ...         # -- Step 8. Multiply the vector by determinant and the integration point weight         Nnc = Nnc* weight * (detJ)                   # add to the RHS vector for accumulation         RHS+=Nnc              # add the element level RHS vector to the global RHS vector b     for i in range(len(element)):         node = int(element[i])         b[node*domain_dim] += RHS[i*domain_dim]         b[node*domain_dim+1] += RHS[(i*domain_dim)+1]  <pre>\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[19], line 10\n      5 # Iterate through all the elements on the left boundary\n      6 for element in elements_left_: \n      7 \n      8     # ------------ User Input required ------------------------------------------#\n      9     # -- Step 1. Set the integration points IP and their weights for 1D element\n---&gt; 10     IPs, IP_weights = ...\n     12     # -- Step 2. Create empty RHS vector for element level force accumulation ------------#\n     13     # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\n     14     RHS = np.zeros((len(element)*domain_dim)) \n\nTypeError: cannot unpack non-iterable ellipsis object</pre> Solution. (*Hidden content here, visible but not collapsible on GitHub.*)     Solution code. Copy from here &gt;     ``` # set force value P = 80 b = np.zeros((num_nodes*domain_dim,)) # Iterate through all the elements on the left boundary for element in elements_left_:   <pre><code># ------------ User Input required ------------------------------------------#\n# -- Step 1. Set the integration points IP and their weights for 1D element\nIPs, IP_weights = Integration_points_1D()\n\n# -- Step 2. Create empty RHS vector for element level force accumulation ------------#\n# -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\nRHS = np.zeros((len(element)*domain_dim)) \n\n# -- Step 3. Set up for loop to iterate over each integration point ------------#\nfor IP, weight in zip(IPs,IP_weights):\n\n    # take the y-coordinate of the middle node as the average of the element\n   # y_value_ = FEM_.mesh.points[element[2]][1] \n    y_value_ = 0.5*(FEM_.mesh.points[element[0]][1] +\\\n                    FEM_.mesh.points[element[1]][1])\n    \n    # initialise the empty traction vector in x- and y-directions respectively\n    traction = [0,0]\n    # set the traction in the x-direction\n    traction[0]= 0.\n     # calculate the traction in y-direction\n    traction[1] = (3. / 4.) * (P / c) * (1. - pow((y_value_ / c), 2))\n\n    # -- Step 4. Get the list of corner nodes in the element and calculate\n    # --------   the Jacobian matrix in 1D using function Jacobian_1D\n    e_nodes_xy = FEM_.global_node_coords[element][:,:3]\n    detJ = Jacobian_1D(IP, e_nodes_xy)\n    # -- Step 5. Calculate the basis functions of 1D element\n    N = basis_fun_line_quad(IP)\n\n    # -- Step 6. Create an empty vector for adjusted shape functions\n    Nnc = np.zeros(len(N)*domain_dim) \n    \n    # -- Step 7. Adjust the basis function vector for 2 d.o.f \n    # ---------   and multiply by the traction force in that direction\n    # iterate through all the nodes in element\n    for node_i in range(len(N)):\n        # for each node consider two degrees of freedom\n        for dof in range(domain_dim):  # for every dimension\n                Nnc[node_i * 2 + dof] += N[node_i] * traction[dof]\n    # -- Step 8. Multiply the vector by determinant and the integration point weight\n    Nnc = Nnc* weight * (detJ) \n    \n    # add to the RHS vector for accumulation\n    RHS+=Nnc\n    \n# add the element level RHS vector to the global RHS vector b\nfor i in range(len(element)):\n    node = int(element[i])\n    b[node*domain_dim] += RHS[i*domain_dim]\n    b[node*domain_dim+1] += RHS[(i*domain_dim)+1]\n\n```\nEnd of Solution</code></pre> In\u00a0[20]: Copied! <pre># set force value\nP = 80\nb = np.zeros((num_nodes*domain_dim,))\n# Iterate through all the elements on the left boundary\nfor element in elements_left_: \n\n    # ------------ User Input required ------------------------------------------#\n    # -- Step 1. Set the integration points IP and their weights for 1D element\n    IPs, IP_weights = integration_points_1D()\n\n    # -- Step 2. Create empty RHS vector for element level force accumulation ------------#\n    # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\n    RHS = np.zeros((len(element)*domain_dim)) \n\n    # -- Step 3. Set up for loop to iterate over each integration point ------------#\n    for IP, weight in zip(IPs,IP_weights):\n\n        # take the y-coordinate of the middle node as the average of the element\n       # y_value_ = FEM_.mesh.points[element[2]][1] \n        y_value_ = 0.5*(FEM_.mesh.points[element[0]][1] +\\\n                        FEM_.mesh.points[element[1]][1])\n        \n        # initialise the empty traction vector in x- and y-directions respectively\n        traction = [0,0]\n        # set the traction in the x-direction\n        traction[0]= 0.\n         # calculate the traction in y-direction\n        traction[1] = (3. / 4.) * (P / c) * (1. - pow((y_value_ / c), 2))\n\n        # -- Step 4. Get the list of corner nodes in the element and calculate\n        # --------   the Jacobian matrix in 1D using function Jacobian_1D\n        e_nodes_xy = FEM_.global_node_coords[element][:,:3]\n        detJ = jacobian_1D(IP, e_nodes_xy)\n        # -- Step 5. Calculate the basis functions of 1D element\n        N = basis_fun_line_quad(IP)\n    \n        # -- Step 6. Create an empty vector for adjusted shape functions\n        Nnc = np.zeros(len(N)*domain_dim) \n        \n        # -- Step 7. Adjust the basis function vector for 2 d.o.f \n        # ---------   and multiply by the traction force in that direction\n        # iterate through all the nodes in element\n        for node_i in range(len(N)):\n            # for each node consider two degrees of freedom\n            for dof in range(domain_dim):  # for every dimension\n                    Nnc[node_i * 2 + dof] += N[node_i] * traction[dof]\n        # -- Step 8. Multiply the vector by determinant and the integration point weight\n        Nnc = Nnc* weight * (detJ) \n        \n        # add to the RHS vector for accumulation\n        RHS+=Nnc\n        \n    # add the element level RHS vector to the global RHS vector b\n    for i in range(len(element)):\n        node = int(element[i])\n        b[node*domain_dim] += RHS[i*domain_dim]\n        b[node*domain_dim+1] += RHS[(i*domain_dim)+1]\n</pre> # set force value P = 80 b = np.zeros((num_nodes*domain_dim,)) # Iterate through all the elements on the left boundary for element in elements_left_:       # ------------ User Input required ------------------------------------------#     # -- Step 1. Set the integration points IP and their weights for 1D element     IPs, IP_weights = integration_points_1D()      # -- Step 2. Create empty RHS vector for element level force accumulation ------------#     # -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f     RHS = np.zeros((len(element)*domain_dim))       # -- Step 3. Set up for loop to iterate over each integration point ------------#     for IP, weight in zip(IPs,IP_weights):          # take the y-coordinate of the middle node as the average of the element        # y_value_ = FEM_.mesh.points[element[2]][1]          y_value_ = 0.5*(FEM_.mesh.points[element[0]][1] +\\                         FEM_.mesh.points[element[1]][1])                  # initialise the empty traction vector in x- and y-directions respectively         traction = [0,0]         # set the traction in the x-direction         traction[0]= 0.          # calculate the traction in y-direction         traction[1] = (3. / 4.) * (P / c) * (1. - pow((y_value_ / c), 2))          # -- Step 4. Get the list of corner nodes in the element and calculate         # --------   the Jacobian matrix in 1D using function Jacobian_1D         e_nodes_xy = FEM_.global_node_coords[element][:,:3]         detJ = jacobian_1D(IP, e_nodes_xy)         # -- Step 5. Calculate the basis functions of 1D element         N = basis_fun_line_quad(IP)              # -- Step 6. Create an empty vector for adjusted shape functions         Nnc = np.zeros(len(N)*domain_dim)                   # -- Step 7. Adjust the basis function vector for 2 d.o.f          # ---------   and multiply by the traction force in that direction         # iterate through all the nodes in element         for node_i in range(len(N)):             # for each node consider two degrees of freedom             for dof in range(domain_dim):  # for every dimension                     Nnc[node_i * 2 + dof] += N[node_i] * traction[dof]         # -- Step 8. Multiply the vector by determinant and the integration point weight         Nnc = Nnc* weight * (detJ)                   # add to the RHS vector for accumulation         RHS+=Nnc              # add the element level RHS vector to the global RHS vector b     for i in range(len(element)):         node = int(element[i])         b[node*domain_dim] += RHS[i*domain_dim]         b[node*domain_dim+1] += RHS[(i*domain_dim)+1]  In\u00a0[85]: Copied! <pre># check all the nodes along the right boundary\nfor node in nodes_on_right_:\n    \n    # get the global coordinate of each node\n    x_val = FEM_.mesh.points[node][0]\n    y_val = FEM_.mesh.points[node][1]\n    # ------------ User Input required ------------------------------------------#\n    \n    # -- Step 1. Check if y coordinate is equal to 0\n    if(...):\n        \n        # -- Step 2. Set the b vector to 0 at both (x- and y-) degrees of freedom of that node\n        # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n        \n        # ------ x-direction\n        A_matrix...\n        A_matrix...\n        b...\n        \n        # ------ y-direction\n        A_matrix...\n        A_matrix...\n        b...\n\n\n    # -- Step 3. Check if y coordinate is equal to either c or -c\n    if(...):\n        \n        # -- Step 4. Set the b vector to 0 at degrees of freedom  in x-direction for that node\n        # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n        A_matrix...\n        A_matrix...\n        b...\n</pre> # check all the nodes along the right boundary for node in nodes_on_right_:          # get the global coordinate of each node     x_val = FEM_.mesh.points[node][0]     y_val = FEM_.mesh.points[node][1]     # ------------ User Input required ------------------------------------------#          # -- Step 1. Check if y coordinate is equal to 0     if(...):                  # -- Step 2. Set the b vector to 0 at both (x- and y-) degrees of freedom of that node         # ---------  Hint. Do not forget to set the A_matrix rows to identity row                  # ------ x-direction         A_matrix...         A_matrix...         b...                  # ------ y-direction         A_matrix...         A_matrix...         b...       # -- Step 3. Check if y coordinate is equal to either c or -c     if(...):                  # -- Step 4. Set the b vector to 0 at degrees of freedom  in x-direction for that node         # ---------  Hint. Do not forget to set the A_matrix rows to identity row         A_matrix...         A_matrix...         b...   <pre>\n  Cell In[85], line 16\n    A_matrix...\n            ^\nSyntaxError: invalid syntax\n</pre> Solution. (*Hidden content here, visible but not collapsible on GitHub.*)     Solution code. Copy from here &gt;     ``` # check all the nodes along the right boundary for node in nodes_on_right_:  <pre><code># get the global coordinate of each node\nx_val = FEM_.mesh.points[node][0]\ny_val = FEM_.mesh.points[node][1]\n# ------------ User Input required ------------------------------------------#\n\n# -- Step 1. Check if y coordinate is equal to 0\nif(np.isclose(y_val,0)):\n    \n    # -- Step 2. Set the b vector to 0 at both (x- and y-) degrees of freedom of that node\n    # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n    A_matrix[node*2,:] = 0\n    A_matrix[node*2, node*2] = 1\n    b[node*2 ] = 0\n\n    A_matrix[node*2+1,:] = 0\n    A_matrix[node*2+1, node*2+1] = 1\n    b[node*2 ] = 0\n\n\n# -- Step 3. Check if y coordinate is equal to either c or -c\nif(np.isclose(abs(y_val),c)):\n    \n    # -- Step 4. Set the b vector to 0 at degrees of freedom  in x-direction for that node\n    # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n    A_matrix[node*2,:] = 0\n    A_matrix[node*2, node*2] = 1\n    b[node*2 ] = 0\n\n\n\n```\nEnd of Solution</code></pre> In\u00a0[21]: Copied! <pre># check all the nodes along the right boundary\nfor node in nodes_on_right_:\n    \n    # get the global coordinate of each node\n    x_val = FEM_.mesh.points[node][0]\n    y_val = FEM_.mesh.points[node][1]\n    # ------------ User Input required ------------------------------------------#\n    \n    # -- Step 1. Check if y coordinate is equal to 0\n    if(np.isclose(y_val,0)):\n        \n        # -- Step 2. Set the b vector to 0 at both (x- and y-) degrees of freedom of that node\n        # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n        A_matrix[node*2,:] = 0\n        A_matrix[node*2, node*2] = 1\n        b[node*2 ] = 0\n\n        A_matrix[node*2+1,:] = 0\n        A_matrix[node*2+1, node*2+1] = 1\n        b[node*2 ] = 0\n\n\n    # -- Step 3. Check if y coordinate is equal to either c or -c\n    if(np.isclose(abs(y_val),c)):\n        \n        # -- Step 4. Set the b vector to 0 at degrees of freedom  in x-direction for that node\n        # ---------  Hint. Do not forget to set the A_matrix rows to identity row\n        A_matrix[node*2,:] = 0\n        A_matrix[node*2, node*2] = 1\n        b[node*2 ] = 0\n</pre> # check all the nodes along the right boundary for node in nodes_on_right_:          # get the global coordinate of each node     x_val = FEM_.mesh.points[node][0]     y_val = FEM_.mesh.points[node][1]     # ------------ User Input required ------------------------------------------#          # -- Step 1. Check if y coordinate is equal to 0     if(np.isclose(y_val,0)):                  # -- Step 2. Set the b vector to 0 at both (x- and y-) degrees of freedom of that node         # ---------  Hint. Do not forget to set the A_matrix rows to identity row         A_matrix[node*2,:] = 0         A_matrix[node*2, node*2] = 1         b[node*2 ] = 0          A_matrix[node*2+1,:] = 0         A_matrix[node*2+1, node*2+1] = 1         b[node*2 ] = 0       # -- Step 3. Check if y coordinate is equal to either c or -c     if(np.isclose(abs(y_val),c)):                  # -- Step 4. Set the b vector to 0 at degrees of freedom  in x-direction for that node         # ---------  Hint. Do not forget to set the A_matrix rows to identity row         A_matrix[node*2,:] = 0         A_matrix[node*2, node*2] = 1         b[node*2 ] = 0   In\u00a0[22]: Copied! <pre>## solve the linear system of equations\nx = FEM_.solve(A_matrix, b)\n</pre> ## solve the linear system of equations x = FEM_.solve(A_matrix, b)  In\u00a0[24]: Copied! <pre>FEM_.write_vtk(\"displacement\", \"vector\", \"cantilever_results\")\n</pre> FEM_.write_vtk(\"displacement\", \"vector\", \"cantilever_results\") In\u00a0[25]: Copied! <pre># ------------ User Input required ------------------------------------------#\ntest_line_though = 1.5 ## set to a value between -1.5 and 1.5.\n\n\n# ------------ End of Input  -------------------------------------------------#\n    \n# Identify the nodes on the top boundary, i.e. where the y0coordinate is equal to c=1.5\nnodes_on_line_ = np.where(np.isclose(FEM_.mesh.points[:,1],test_line_though))[0]\n\n# Initialise empty arrays to store the numerical and analytical solutions\nanalytical_solution_x =np.empty((0,2))\nFEM_solution_x =np.empty((0,2))\n\nanalytical_solution_y =np.empty((0,2))\nFEM_solution_y =np.empty((0,2))\n\n# Iterate through the sampling nodes\nfor node in nodes_on_line_:\n    # find the global coordinates for the node\n    x_val = round(FEM_.mesh.points[node][0],5)\n    y_val = round(FEM_.mesh.points[node][1],5)\n    \n    ## get the numerical and analytical solutions for displacement in x\n    FEM_x = x[node*2]\n    analytical_x = FEM_.analytical_solution_x(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)\n    \n    ## get the numerical and analytical solutions for displacement in y\n    FEM_y = x[node*2+1]\n    analytical_y = FEM_.analytical_solution_y(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)\n    \n    # append the the list of solutions for plotting\n    analytical_solution_x=np.append(analytical_solution_x,[[x_val,analytical_x]], axis = 0)\n    analytical_solution_y=np.append(analytical_solution_y,[[x_val,analytical_y]], axis = 0)\n    \n    FEM_solution_x=np.append(FEM_solution_x,[[x_val,FEM_x]], axis=0)\n    FEM_solution_y=np.append(FEM_solution_y,[[x_val,FEM_y]], axis=0)\n    \n## Plot the numerical and analytical solution\n\n# Create a figure with 1 row and 2 columns\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))  \n\n# First subplot (Displacmenet in X)\naxes[0].plot(FEM_solution_x[:, 0], FEM_solution_x[:, 1], \"o\", color=\"royalblue\", markersize=6, label=\"FEM\")\naxes[0].plot(analytical_solution_x[:, 0], analytical_solution_x[:, 1], \"x\", color=\"crimson\", markersize=6, label=\"Analytical\")\naxes[0].set_xlabel(\"x-coordinate\")\naxes[0].set_ylabel(\"Displacement in x\")\naxes[0].set_title(\"FEM vs Analytical Solutions (Displacement x)\")\naxes[0].legend()\naxes[0].grid(True, linestyle=\"--\", alpha=0.6)\naxes[0].set_ylim([-0.005, 0.12])  \n\n# Second subplot (Displacmenet in Y)\naxes[1].plot(FEM_solution_y[:, 0], FEM_solution_y[:, 1], \"o\", color=\"royalblue\", markersize=6, label=\"FEM\")\naxes[1].plot(analytical_solution_y[:, 0], analytical_solution_y[:, 1], \"x\", color=\"crimson\", markersize=6, label=\"Analytical\")\naxes[1].set_xlabel(\"x-coordinate\")\naxes[1].set_ylabel(\"Displacement in y\")\naxes[1].set_title(\"FEM vs Analytical Solutions (Displacement y)\")\naxes[1].legend()\naxes[1].grid(True, linestyle=\"--\", alpha=0.6)\n\nplt.tight_layout()\nplt.show()\n</pre> # ------------ User Input required ------------------------------------------# test_line_though = 1.5 ## set to a value between -1.5 and 1.5.   # ------------ End of Input  -------------------------------------------------#      # Identify the nodes on the top boundary, i.e. where the y0coordinate is equal to c=1.5 nodes_on_line_ = np.where(np.isclose(FEM_.mesh.points[:,1],test_line_though))[0]  # Initialise empty arrays to store the numerical and analytical solutions analytical_solution_x =np.empty((0,2)) FEM_solution_x =np.empty((0,2))  analytical_solution_y =np.empty((0,2)) FEM_solution_y =np.empty((0,2))  # Iterate through the sampling nodes for node in nodes_on_line_:     # find the global coordinates for the node     x_val = round(FEM_.mesh.points[node][0],5)     y_val = round(FEM_.mesh.points[node][1],5)          ## get the numerical and analytical solutions for displacement in x     FEM_x = x[node*2]     analytical_x = FEM_.analytical_solution_x(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)          ## get the numerical and analytical solutions for displacement in y     FEM_y = x[node*2+1]     analytical_y = FEM_.analytical_solution_y(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)          # append the the list of solutions for plotting     analytical_solution_x=np.append(analytical_solution_x,[[x_val,analytical_x]], axis = 0)     analytical_solution_y=np.append(analytical_solution_y,[[x_val,analytical_y]], axis = 0)          FEM_solution_x=np.append(FEM_solution_x,[[x_val,FEM_x]], axis=0)     FEM_solution_y=np.append(FEM_solution_y,[[x_val,FEM_y]], axis=0)      ## Plot the numerical and analytical solution  # Create a figure with 1 row and 2 columns fig, axes = plt.subplots(1, 2, figsize=(12, 5))    # First subplot (Displacmenet in X) axes[0].plot(FEM_solution_x[:, 0], FEM_solution_x[:, 1], \"o\", color=\"royalblue\", markersize=6, label=\"FEM\") axes[0].plot(analytical_solution_x[:, 0], analytical_solution_x[:, 1], \"x\", color=\"crimson\", markersize=6, label=\"Analytical\") axes[0].set_xlabel(\"x-coordinate\") axes[0].set_ylabel(\"Displacement in x\") axes[0].set_title(\"FEM vs Analytical Solutions (Displacement x)\") axes[0].legend() axes[0].grid(True, linestyle=\"--\", alpha=0.6) axes[0].set_ylim([-0.005, 0.12])    # Second subplot (Displacmenet in Y) axes[1].plot(FEM_solution_y[:, 0], FEM_solution_y[:, 1], \"o\", color=\"royalblue\", markersize=6, label=\"FEM\") axes[1].plot(analytical_solution_y[:, 0], analytical_solution_y[:, 1], \"x\", color=\"crimson\", markersize=6, label=\"Analytical\") axes[1].set_xlabel(\"x-coordinate\") axes[1].set_ylabel(\"Displacement in y\") axes[1].set_title(\"FEM vs Analytical Solutions (Displacement y)\") axes[1].legend() axes[1].grid(True, linestyle=\"--\", alpha=0.6)  plt.tight_layout() plt.show()  <p>From the graphs above we can see that the Finite Element solution is close to the analytical solution. Note that the largest differences are at the left boundary where we specified the Neumann boundary condition, while on the right boundary the solution matches exactly, where we have Dirichlet boundary condition.</p> <p>While this type of solution review is useful. It doesn't quantify the error or show if there is an issue elsewhere. Therefore, it is also good practice to perform error analysis and asses the error across all nodes.</p> In\u00a0[26]: Copied! <pre># Setting problem input\nL=x_end- x_start\nP=80\nYoungs_modulus = 1e6\nPoisson_ratio = 0.25\n</pre> # Setting problem input L=x_end- x_start P=80 Youngs_modulus = 1e6 Poisson_ratio = 0.25 In\u00a0[27]: Copied! <pre>from FEM_Module.Run_Cantilever_Example import Run_Cantilever\n\n# ------------ User Input required ------------------------------------------#\n\nelement_sizes=[2.2,2,1.45,0.9] # provide in list form the different element sizes\n\n# ------------ End of User Input  ------------------------------------------#\n\nerrors_summary_x = np.empty((0,4))\nerrors_summary_y = np.empty((0,4))\n\nfor element_size in element_sizes:\n    \n    FEM_ = Run_Cantilever(domain_dim)\n\n    ## Create the domain name\n    FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])\n    FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)\n    FEM_.apply_BC_NeumannDirich(P)\n    FEM_.solve(FEM_.A_matrix,FEM_.b)\n\n    ## Calculate the error\n    x = FEM_.x\n    \n    # Set up empty containers for errors\n    error_abs = np.empty((0,2))\n    error_mse = np.empty((0,2))\n    y_sol = np.empty((0,3))\n    x_sol = np.empty((0,3))\n    \n    for node_ID in range(len(FEM_.mesh.points)):\n        x_val, y_val = FEM_.mesh.points[node_ID][0],FEM_.mesh.points[node_ID][1]\n\n        # Get analytical solution for the node\n        analytical_disp_x = FEM_.analytical_solution_x(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)\n        analytical_disp_y = FEM_.analytical_solution_y(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)\n\n        # ------------ User Input required ------------------------------------------#\n        # Get the numerical displacement at the node from solution vector x\n        numerical_disp_x = x[node_ID * domain_dim]\n        numerical_disp_y = x[node_ID * domain_dim + 1]\n\n        # Absolute error:\n        error_x = abs(numerical_disp_x-analytical_disp_x)\n        error_y = abs(numerical_disp_y-analytical_disp_y)\n        \n        error_abs=np.append(error_abs,[[error_x,error_y]], axis = 0)\n        \n        # MSE error:\n        error_x = pow((numerical_disp_x-analytical_disp_x),2)\n        error_y = pow((numerical_disp_y-analytical_disp_y),2)\n        \n        error_mse = np.append(error_mse,[[error_x,error_y]], axis = 0)\n\n        # ------------ End of User Input  ------------------------------------------#\n        \n    print(\"For mesh with element sizes \", element_size)\n    print(\"There are\", len(FEM_.mesh.cells_dict['triangle6']), \"elements\")\n    print(\"The absolute errors are:\", f\"{np.mean(error_abs[:,0]):.4f}\", f\"{np.mean(error_abs[:,1]):.4f}\")\n    print(\"The max errors are:\", f\"{np.max(error_abs[:,0]):.4f}\", f\"{np.max(error_abs[:,1]):.4f}\")\n    print(\"The MSE errors are:\", f\"{np.mean(error_mse[:,0]):.8f}\", f\"{np.mean(error_mse[:,1]):.8f}\")\n    print()\n\n    errors_summary_x = np.append(errors_summary_x,[[len(FEM_.mesh.cells_dict['triangle6']), np.max(error_abs[:,0]),\\\n                                                   np.mean(error_abs[:,0]),np.mean(error_mse[:,0])]], axis = 0)\n\n    errors_summary_y = np.append(errors_summary_y,[[len(FEM_.mesh.cells_dict['triangle6']), np.max(error_abs[:,1]),\\\n                                                   np.mean(error_abs[:,1]),np.mean(error_mse[:,1])]], axis = 0)\n    \n</pre> from FEM_Module.Run_Cantilever_Example import Run_Cantilever  # ------------ User Input required ------------------------------------------#  element_sizes=[2.2,2,1.45,0.9] # provide in list form the different element sizes  # ------------ End of User Input  ------------------------------------------#  errors_summary_x = np.empty((0,4)) errors_summary_y = np.empty((0,4))  for element_size in element_sizes:          FEM_ = Run_Cantilever(domain_dim)      ## Create the domain name     FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])     FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)     FEM_.apply_BC_NeumannDirich(P)     FEM_.solve(FEM_.A_matrix,FEM_.b)      ## Calculate the error     x = FEM_.x          # Set up empty containers for errors     error_abs = np.empty((0,2))     error_mse = np.empty((0,2))     y_sol = np.empty((0,3))     x_sol = np.empty((0,3))          for node_ID in range(len(FEM_.mesh.points)):         x_val, y_val = FEM_.mesh.points[node_ID][0],FEM_.mesh.points[node_ID][1]          # Get analytical solution for the node         analytical_disp_x = FEM_.analytical_solution_x(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)         analytical_disp_y = FEM_.analytical_solution_y(x_val,y_val,P,L,Youngs_modulus,Poisson_ratio,c,t)          # ------------ User Input required ------------------------------------------#         # Get the numerical displacement at the node from solution vector x         numerical_disp_x = x[node_ID * domain_dim]         numerical_disp_y = x[node_ID * domain_dim + 1]          # Absolute error:         error_x = abs(numerical_disp_x-analytical_disp_x)         error_y = abs(numerical_disp_y-analytical_disp_y)                  error_abs=np.append(error_abs,[[error_x,error_y]], axis = 0)                  # MSE error:         error_x = pow((numerical_disp_x-analytical_disp_x),2)         error_y = pow((numerical_disp_y-analytical_disp_y),2)                  error_mse = np.append(error_mse,[[error_x,error_y]], axis = 0)          # ------------ End of User Input  ------------------------------------------#              print(\"For mesh with element sizes \", element_size)     print(\"There are\", len(FEM_.mesh.cells_dict['triangle6']), \"elements\")     print(\"The absolute errors are:\", f\"{np.mean(error_abs[:,0]):.4f}\", f\"{np.mean(error_abs[:,1]):.4f}\")     print(\"The max errors are:\", f\"{np.max(error_abs[:,0]):.4f}\", f\"{np.max(error_abs[:,1]):.4f}\")     print(\"The MSE errors are:\", f\"{np.mean(error_mse[:,0]):.8f}\", f\"{np.mean(error_mse[:,1]):.8f}\")     print()      errors_summary_x = np.append(errors_summary_x,[[len(FEM_.mesh.cells_dict['triangle6']), np.max(error_abs[:,0]),\\                                                    np.mean(error_abs[:,0]),np.mean(error_mse[:,0])]], axis = 0)      errors_summary_y = np.append(errors_summary_y,[[len(FEM_.mesh.cells_dict['triangle6']), np.max(error_abs[:,1]),\\                                                    np.mean(error_abs[:,1]),np.mean(error_mse[:,1])]], axis = 0)      <pre>For mesh with element sizes  2.2\nThere are 118 elements\nThe absolute errors are: 0.0036 0.1046\nThe max errors are: 0.0078 0.2423\nThe MSE errors are: 0.00001903 0.01670983\n\nFor mesh with element sizes  2\nThere are 122 elements\nThe absolute errors are: 0.0032 0.0913\nThe max errors are: 0.0072 0.2168\nThe MSE errors are: 0.00001567 0.01278845\n\nFor mesh with element sizes  1.45\nThere are 260 elements\nThe absolute errors are: 0.0017 0.0622\nThe max errors are: 0.0036 0.1181\nThe MSE errors are: 0.00000399 0.00509172\n\nFor mesh with element sizes  0.9\nThere are 548 elements\nThe absolute errors are: 0.0014 0.0610\nThe max errors are: 0.0045 0.1013\nThe MSE errors are: 0.00000300 0.00457691\n\n</pre> <p>Plotting the errors is a valuable way to visualise how the numerical solution converges to the analytical one. As the mesh is refined (i.e., as the number of elements increases), we generally expect the errors to decrease.</p> <p>It is also important to analyse different types of errors, as each provides different insights. For instance, the maximum error is easy to compute but can be misleading since it is based on a single value. In the plot below, we observe a general reduction in errors. However, because the errors are becoming very small, a slight increase in a single value can cause the maximum error to rise, which may be misleading.</p> <p>It is also essential to consider the trade-off between improved accuracy and increased computational cost. For the last two element sizes, 0.9 and 0.6, the number of elements doubles, yet the reduction in all errors is only minimal. Further error reduction would require doubling the elements again, but the error convergence graphs indicate that the solution is nearly converged. Therefore, refining the mesh further may not be worthwhile due to the additional computational time and cost.</p> In\u00a0[28]: Copied! <pre>fig, axes = plt.subplots(3, 2, figsize=(10, 10))\n\n# Define row titles for subtitles\nrow_titles = [\"Max Error\", \"Absolute Error\", \"MSE Error\"]\ndimention_title = [\"in x-axis\", \"in y-axis\"]\nfor fig_num in range(1, 4):\n    axes[fig_num - 1][0].plot(errors_summary_x[:, 0], errors_summary_x[:, fig_num])\n    axes[fig_num - 1][1].plot(errors_summary_y[:, 0], errors_summary_y[:, fig_num])\n    for col in range(2):\n    # Set subtitles for each row\n        axes[fig_num - 1][col].set_title(row_titles[fig_num - 1]+\" \"+dimention_title[col])\n        axes[fig_num - 1][col].set_xlabel(\"Number of Elements in \")\n        axes[fig_num - 1][col].set_ylabel(\"Error\")\n        axes[fig_num - 1][col].grid(True)\n        \n\nplt.tight_layout()\nplt.show()\n</pre> fig, axes = plt.subplots(3, 2, figsize=(10, 10))  # Define row titles for subtitles row_titles = [\"Max Error\", \"Absolute Error\", \"MSE Error\"] dimention_title = [\"in x-axis\", \"in y-axis\"] for fig_num in range(1, 4):     axes[fig_num - 1][0].plot(errors_summary_x[:, 0], errors_summary_x[:, fig_num])     axes[fig_num - 1][1].plot(errors_summary_y[:, 0], errors_summary_y[:, fig_num])     for col in range(2):     # Set subtitles for each row         axes[fig_num - 1][col].set_title(row_titles[fig_num - 1]+\" \"+dimention_title[col])         axes[fig_num - 1][col].set_xlabel(\"Number of Elements in \")         axes[fig_num - 1][col].set_ylabel(\"Error\")         axes[fig_num - 1][col].grid(True)           plt.tight_layout() plt.show()  In\u00a0[29]: Copied! <pre>from FEM_Module.Run_Cantilever_Example import Run_Cantilever\n\nelement_sizes=[3.,2.2,2,1.45,0.9]\n\n# ------------ Neumann Boundary Conditions ------------------------------------------#\nerrors_summary_x_N = []\nerrors_summary_y_N = []\n\nfor element_size in element_sizes:\n    \n    FEM_ = Run_Cantilever(domain_dim)\n\n    ## Create the domain name\n    FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])\n    FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)\n    FEM_.apply_BC_NeumannDirich(P)\n    FEM_.solve(FEM_.A_matrix,FEM_.b)\n\n    errors_x, errors_y = FEM_.calculate_errors(P, L,c)\n        \n    errors_summary_x_N.append(errors_x)\n\n    errors_summary_y_N.append(errors_y)\n\n# ------------ Dirichlet Boundary Conditions ------------------------------------------#\nerrors_summary_x_D = []\nerrors_summary_y_D = []\n\nfor element_size in element_sizes:\n    \n    FEM_ = Run_Cantilever(domain_dim)\n\n    ## Create the domain name\n    FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])\n    FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)\n    FEM_.apply_BC_Dirich(P)\n    FEM_.solve(FEM_.A_matrix,FEM_.b)\n\n    errors_x, errors_y = FEM_.calculate_errors(P, L,c)\n        \n    errors_summary_x_D.append(errors_x)\n    errors_summary_y_D.append(errors_y)\n\n# ------------ Plot the errors ------------------------------------------#\n\nfig, axes = plt.subplots(3, 2, figsize=(10, 10))\n\ndimention_title = [\"in x-axis\", \"in y-axis\"]\nerrors_summary_x_D =np.array(errors_summary_x_D)\nerrors_summary_y_D =np.array(errors_summary_y_D)\nerrors_summary_x_N =np.array(errors_summary_x_N)\nerrors_summary_y_N =np.array(errors_summary_y_N)\n# Define row titles for subtitles\nrow_titles = [\"Max Error\", \"Absolute Error\", \"MSE Error\"]\n\nfor fig_num in range(1, 4):\n    axes[fig_num - 1][0].plot(errors_summary_x_N[:, 0], errors_summary_x_N[:, fig_num], label=\"Neumann BC\")\n    axes[fig_num - 1][1].plot(errors_summary_y_N[:, 0], errors_summary_y_N[:, fig_num], label=\"Neumann BC\")\n    axes[fig_num - 1][0].plot(errors_summary_x_D[:, 0], errors_summary_x_D[:, fig_num], label=\"Dirich BC\")\n    axes[fig_num - 1][1].plot(errors_summary_y_D[:, 0], errors_summary_y_D[:, fig_num], label=\"Dirich BC\")\n    for col in range(2):\n    # Set subtitles for each row\n        axes[fig_num - 1][col].set_title(row_titles[fig_num - 1]+\" \"+dimention_title[col])\n        axes[fig_num - 1][col].set_xlabel(\"Number of Elements\")\n        axes[fig_num - 1][col].set_ylabel(\"Error\")\n        axes[fig_num - 1][col].grid(True)\n        \n    axes[fig_num - 1][0].legend()\n    axes[fig_num - 1][1].legend()\n\nplt.tight_layout()\nplt.show()\n</pre> from FEM_Module.Run_Cantilever_Example import Run_Cantilever  element_sizes=[3.,2.2,2,1.45,0.9]  # ------------ Neumann Boundary Conditions ------------------------------------------# errors_summary_x_N = [] errors_summary_y_N = []  for element_size in element_sizes:          FEM_ = Run_Cantilever(domain_dim)      ## Create the domain name     FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])     FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)     FEM_.apply_BC_NeumannDirich(P)     FEM_.solve(FEM_.A_matrix,FEM_.b)      errors_x, errors_y = FEM_.calculate_errors(P, L,c)              errors_summary_x_N.append(errors_x)      errors_summary_y_N.append(errors_y)  # ------------ Dirichlet Boundary Conditions ------------------------------------------# errors_summary_x_D = [] errors_summary_y_D = []  for element_size in element_sizes:          FEM_ = Run_Cantilever(domain_dim)      ## Create the domain name     FEM_.domain_mesh(element_degree, element_size, [x_start,x_end], [y_start,y_end])     FEM_.accumulate_global_matrix(Youngs_modulus, Poisson_ratio)     FEM_.apply_BC_Dirich(P)     FEM_.solve(FEM_.A_matrix,FEM_.b)      errors_x, errors_y = FEM_.calculate_errors(P, L,c)              errors_summary_x_D.append(errors_x)     errors_summary_y_D.append(errors_y)  # ------------ Plot the errors ------------------------------------------#  fig, axes = plt.subplots(3, 2, figsize=(10, 10))  dimention_title = [\"in x-axis\", \"in y-axis\"] errors_summary_x_D =np.array(errors_summary_x_D) errors_summary_y_D =np.array(errors_summary_y_D) errors_summary_x_N =np.array(errors_summary_x_N) errors_summary_y_N =np.array(errors_summary_y_N) # Define row titles for subtitles row_titles = [\"Max Error\", \"Absolute Error\", \"MSE Error\"]  for fig_num in range(1, 4):     axes[fig_num - 1][0].plot(errors_summary_x_N[:, 0], errors_summary_x_N[:, fig_num], label=\"Neumann BC\")     axes[fig_num - 1][1].plot(errors_summary_y_N[:, 0], errors_summary_y_N[:, fig_num], label=\"Neumann BC\")     axes[fig_num - 1][0].plot(errors_summary_x_D[:, 0], errors_summary_x_D[:, fig_num], label=\"Dirich BC\")     axes[fig_num - 1][1].plot(errors_summary_y_D[:, 0], errors_summary_y_D[:, fig_num], label=\"Dirich BC\")     for col in range(2):     # Set subtitles for each row         axes[fig_num - 1][col].set_title(row_titles[fig_num - 1]+\" \"+dimention_title[col])         axes[fig_num - 1][col].set_xlabel(\"Number of Elements\")         axes[fig_num - 1][col].set_ylabel(\"Error\")         axes[fig_num - 1][col].grid(True)              axes[fig_num - 1][0].legend()     axes[fig_num - 1][1].legend()  plt.tight_layout() plt.show()  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"Part_2/#part-2","title":"Part 2\u00b6","text":""},{"location":"Part_2/#problem-description","title":"Problem Description\u00b6","text":"<p>Modelling displacement and stress is fundamental in engineering and geoscience, because it allows us to understand the material behaviour under various loads and conditions. Displacement captures the change in position of a point or body from the initial position due to forces. By accurately modelling displacement, we can compute stresses and determine whether a material will deform elastically, yield, or fracture under load. Finite Element Method is widely used to model the displacement and stresses in a domain. In engineering, it helps to ensure structural integrity of buildings, aircraft etc. In geoscience, it is useful in modelling underground structures, such as tunnels, reserviours and modelling fracturing of subsurface.</p> <p>In this example we will model how a cantilever beam will deform when subjected to a point load.</p> <p>Imagine we have a beam of length $L=60$ and height $2c = 3$ that is attached to a wall on one side and there is a load $P =80$ applied to the point on free hanging side. If the load is strong enough, the beam will bend. We can model that deformation using Finite Element Method, by solving for displacement.</p> <p></p> <p>The details and the analytical solution for this exercise can be found in Section 2.9 of book \"The Finite Element Method: Its Basis and Fundamentals\" By Olek C Zienkiewicz, Robert L. Taylor, J.Z. Zhu \u00b7 2005</p>"},{"location":"Part_2/#variational-form-of-linear-elasticity","title":"Variational form of Linear Elasticity\u00b6","text":""},{"location":"Part_2/#equation-of-equilibrium","title":"Equation of Equilibrium\u00b6","text":"<p>To present the weak form of the governing equations for FEM, we must present the concepts of displacement, strain and stresses and how they relate to each other.</p> <ul> <li>displacement ($u$) is the vector that describes the movement of a object</li> <li>strain ($\\varepsilon$) measures the deformation of an object due to applied loads</li> <li>stress ($\\sigma$) measures the internal forces within the material due to the applied loads</li> </ul> <p>In this example we assume linear elasticity relations, meaning that there is a linear relationship between stress and strain. This relationship is true for small deformations (i.e. displacement). However, it does not hold for large displacements, where non-linear relationship arises.</p> <p>The equation of equilibrium states that the sum of internal forces and the external forces must balance out. This equation can be expressed in terms of stress and specifically the two dimensional formulation in $x,y$-coordinates is:</p> <p>$$ \\nabla \\cdot\\sigma + \\textbf{F} = 0$$ $$\\Rightarrow \\begin{vmatrix} \\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} \\end{vmatrix}  \\begin{bmatrix}\\sigma_x &amp; \\tau_{yx}\\\\ \\tau_{xy} &amp; \\sigma_y \\end{bmatrix} = \\begin{bmatrix} Fx\\\\ F_y \\end{bmatrix} $$</p> <p>where $\\nabla$ is the divergence operator $[\\frac{\\partial}{\\partial x},\\frac{\\partial}{\\partial y}]$, $\\sigma$ represents the internal stress matrix: the $\\sigma_x$ and $\\sigma_y$ are normal stresses in directions $x$ and $y$ and $\\tau_{xy}=\\tau_{yx}$ is the shear stress.The $\\textbf{F}$ is a body force per unit area, such as gravity and applied load. In our example we will assume no gravitational forces, for simplicity. That reduces $F$ to forces equivalent to the applied load.</p> <p>In literature the $2x2$ stress matrix $\\sigma$ is often written as vector: $$ \\begin{equation} \\sigma= \\begin{bmatrix}  \\sigma_{x} \\\\  \\sigma_{y} \\\\  \\tau_{xy}  \\end{bmatrix} \\end{equation} $$</p> <p>Using this equation of equilibrium the variational form for Finite Element Method can be derived. While we will not provide the full derivation due to its length, we will outline the key idea that lead to the final result.</p>"},{"location":"Part_2/#derivation-of-variation-form","title":"Derivation of Variation Form\u00b6","text":"<p>Since we are solving for displacement $u$, the variational form must take form in terms of displacement vector. Let us first deal with the left hand side of the equation, while the right hand side are the external stresses that are applied as boundary conditions. We will use the following relations and principle:</p> <ol> <li><p>small strain-displacement relation: This relation expresses strain $\\varepsilon$ in terms of displacement $u$ $$  \\begin{equation}  \\begin{bmatrix}   \\varepsilon_{xx} \\\\   \\varepsilon_{yy} \\\\   \\gamma_{xy}   \\end{bmatrix}  =  \\begin{bmatrix}   \\frac{\\partial u_x}{\\partial x} \\\\   \\frac{\\partial u_y}{\\partial y} \\\\   \\frac{\\partial x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}   \\end{bmatrix}  =  \\begin{bmatrix}   \\frac{\\partial}{\\partial x} &amp; 0 \\\\   0 &amp; \\frac{\\partial}{\\partial y} \\\\   \\frac{\\partial x}{\\partial y} &amp; \\frac{\\partial u_y}{\\partial x}   \\end{bmatrix}  \\begin{bmatrix}  u_x \\\\ u_y  \\end{bmatrix}  \\end{equation}  $$</p> <p>where $u_x$ and $u_y$ is the displacement in $x$ and $y$ directions respectively and $\\varepsilon$ is the strain of the object. It describes how much the object deforms in particular direction: the strains $\\varepsilon_{xx}$ and $\\varepsilon_{yy}$ measure how much the object stretches in the $x$ and $y$ directions respectively, while the $\\varepsilon_{xy}$ is the shear strain that measures how much the object distorts. This equation is often written in form $$\\begin{equation}  \\varepsilon = \\textbf{B}u  \\end{equation}  $$</p> </li> <li><p>small strain-stress relation (Hooke's law for continuous domain) This relation states that we can express stress $\\sigma$ in terms of strain using the material stiffness matrix $\\textbf{D}$:</p> <p>$$\\sigma = \\textbf{D}\\varepsilon$$</p> <p>The matrix $\\textbf{D}$ is defined in section \"Step 3. Matrix Assembly\" below.</p> </li> <li><p>We apply the principle of virtual work (that states for an arbitrary small virtual displacement $\\delta u$ the internal virtual work is equal to external virtual work). Therefore, multiplying the equilibrium equation by the virtual displacement $\\delta u$ and integrating over the domain $\\Omega$ to calculate the total forces we have:</p> </li> </ol> <p>$$\\int_\\Omega \\delta u^T(\\nabla \\cdot\\sigma + \\textbf{F})=0$$</p> <p>Finally by applying the divergence theorem, which allows us to express the integral over the domain in terms of integral over the boundary with respect to normal $\\textbf{n}$, to the principle of work states above and substituting the relations 1 and 2. We get the following variational form of equilibrium equation. $$\\int_\\Omega \\textbf{B}^T \\textbf{D}\\textbf{B} d\\Omega = \\int_{d\\Gamma}\\sigma \\cdot \\textbf{n}d\\Gamma\\$$ where $\\textbf{D}$ is a material matrix from the strain-stress relation, $\\textbf{B}$ is a derivative matrix of displacement $u$ from the strain-displacement relation and $\\sigma$ are the external forces applied at normal $\\textbf{n}$ around domain boundary $\\Gamma$. The left-hand size of the equation is what we will be accumulating on the element-by-element basis into the global matrix $A$ and the right hand side are the boundary conditions.</p> <p>As in Part 1 exercise, let us follow the same structure in setting up the problem.</p> <p>For more information on the linear elasticity and deriving the weak form of the governing equations, see:</p> <p>[1] Section 2 of book \"The Finite Element Method: Its Basis and Fundamentals\" By Olek C Zienkiewicz, Robert L. Taylor, J.Z. Zhu \u00b7 2005</p> <p>[2] https://basicfem.ju.se/WeakFormElasticity2D/</p> <p>[3] https://nitc.ac.in/imgserver/uploads/attachments/Ed__0ac88639-a4dc-40be-8cf9-c797af906431_.pdf</p> <p>[4] http://solidmechanics.org/Text/Chapter7_2/Chapter7_2.php</p>"},{"location":"Part_2/#step-1-domain-set-up-and-meshing","title":"Step 1. Domain Set Up and Meshing\u00b6","text":"<p>The domain set up and meshing does not depend on the solution variable type (i.e. scalar/ vector). Hence, this step is the same as in Part 1. The domain set up only depends on the refinement of the domain and type of elements we want to use. However, it is generally good to review the ODE/PDE that is being solving to understand the degree of the differential equation, as this will guide the element degree. In this example we will use elements of degree two. The function below will create and mesh the domain using the inputs provided below in the same way as in first example.</p>"},{"location":"Part_2/#exercise","title":"Exercise\u00b6","text":"<p>Based on the information provided below, define the domain boundaries by replacing the <code>...</code> placeholders with the appropriate values.:</p> <ul> <li>length in $x$ direction is $60$ from origin</li> <li>length in $y$ direction is $3$ and it is symmetric around the origin</li> <li>two dimensional problem</li> </ul> <p>Then specify the type and size of elements that we want to use:</p> <ul> <li>quadratic elements</li> <li>element size = 1</li> </ul> <p>We can visualise this domain by using the function <code>visualise_mesh()</code> in module FEM_model .</p> <p>Note: The solution is available in the red hidden cell titled \"Solution\" below.</p>"},{"location":"Part_2/#domain-definition","title":"Domain Definition\u00b6","text":"<p>x_start = 0 x_end = 60 y_start = -1.5 y_end = 1.5 domain_dim = 2</p>"},{"location":"Part_2/#input-element-type","title":"Input Element Type\u00b6","text":"<p>element_degree = 2 # specify the element order element_length = 2 # specify the domain refinement. Finer meshes lead to more accurate solution ```</p>"},{"location":"Part_2/#step-2-key-element-functions","title":"Step 2. Key Element Functions\u00b6","text":"<p>One of the key steps in Finite Element Method is applying the basis functions to assemble the linear system of equations that represent the weak form of the governing equation. The basis functions do not change depending on whether the solution is a vector or scalar field. However, the key difference lies in the structure of solution field.</p> <p>Structure of the solution field.</p> <p>In the previous exercise, temperature was treated as a scalar field, meaning each node had only a single associated value. Consequently, there was only one degree of freedom per node. However, when solving for vector fields, multiple degrees of freedom exist at each node because particles can move in multiple dimensions. This is reflected in the structure of the solution vector $u$.</p> <p>There are different ways to organize the solution vector, but it is crucial to maintain consistency in the chosen structure. One approach is to order by dimension, where all degrees of freedom in the $x$-direction appear first, followed by those in the $y$-direction. Alternatively, we can order by node ID, where each node's $x$- and $y$-components are stored consecutively. We adopt the second approach of node ordering, resulting in the following structure for solution vector $u$:</p> <p>$$u=\\begin{bmatrix} u^0_x\\\\ u^0_y \\\\  u^1_x\\\\ u^1_y\\\\... \\\\ u^m_x \\\\ u^m_y  \\end{bmatrix}$$</p> <p>where $u^i_x$ and $u^i_y$ represent the displacement in $x$ and $y$ directions at node $i$ and $m$ is the total number of nodes in the mesh. This structure must be  accounted for when assembling the element-level stiffness matrix into the global system matrix $A$.</p>"},{"location":"Part_2/#step-3-matrix-assembly","title":"Step 3. Matrix Assembly\u00b6","text":"<p>Recall that the left hand side of the weak form that we need to accumulate is $$\\int_\\Omega \\textbf{B}^T \\textbf{D}\\textbf{B} d\\Omega $$</p> <p>Let us now define in more detail what the matrix $\\textbf{B}$ and $\\textbf{D}$ are.</p> <p>From \"Problem Description\" section we have defined the strain in terms of derivative of displacement using the small strain-displacement relation: $$     \\begin{equation}     \\begin{bmatrix}      \\varepsilon_{xx} \\\\      \\varepsilon_{yy} \\\\      \\gamma_{xy}      \\end{bmatrix}     =     \\begin{bmatrix}      \\frac{\\partial}{\\partial x} &amp; 0 \\\\      0 &amp; \\frac{\\partial}{\\partial y} \\\\      \\frac{\\partial x}{\\partial y} &amp; \\frac{\\partial u_y}{\\partial x}      \\end{bmatrix}     \\begin{bmatrix}     u_x \\\\ u_y     \\end{bmatrix}     \\end{equation}     =\\textbf{Bu}     $$ Given that displacement $u$ in any element $e$ can be expressed as the linear combination of the nodes in that element: $$u_x = \\sum_{i=0}^n N^i u_x^i$$ where $N^i$ is the shape function local node $i$ and $n$ is the number of nodes in the element. Then the strain matrix above can be rewritten as :</p> <p>\\begin{equation} \\begin{bmatrix}  \\varepsilon_{xx} \\\\  \\varepsilon_{yy} \\\\  \\gamma_{xy}  \\end{bmatrix} = \\begin{bmatrix}  \\frac{\\partial N^1}{\\partial x} &amp; 0 &amp; \\frac{\\partial N^2}{\\partial x} &amp; 0 &amp;\\cdots&amp; \\frac{\\partial N^n}{\\partial x} &amp; 0\\\\ 0 &amp; \\frac{\\partial N^1}{\\partial y} &amp; 0 &amp; \\frac{\\partial N^2}{\\partial y} &amp;\\cdots&amp; 0 &amp;\\frac{\\partial N^n}{\\partial y}\\\\ \\frac{\\partial N^1}{\\partial y} &amp; \\frac{\\partial N^1}{\\partial x} &amp; \\frac{\\partial N^2}{\\partial y} &amp;\\frac{\\partial N^2}{\\partial x} &amp;\\cdots&amp; \\frac{\\partial N^n}{\\partial y} &amp; \\frac{\\partial N^n}{\\partial x}\\\\ \\end{bmatrix} \\begin{bmatrix} u^0_x\\\\ u^0_y \\\\  u^1_x\\\\ u^1_y\\\\\\vdots \\\\ u^n_x \\\\ u^n_y \\end{bmatrix} = \\textbf{B}u \\end{equation}</p> <p>We have also previously defined strain-stress relation as $$\\sigma = \\textbf{D}\\varepsilon$$ where matrix $\\textbf{D}$ is</p> <p>\\begin{equation} \\textbf{D} = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} \\bigg[ \\begin{array}{cc}  1 &amp; \\frac{\\nu}{1-\\nu}\\\\ \\frac{\\nu}{1-\\nu} &amp; \\frac{1-2\\nu}{2(1-\\nu)} \\end{array} \\bigg] \\end{equation}</p> <p>where $E$ and $\\nu$ are the material properties: the Young's modulus and the Poisson ratio respectively.</p>"},{"location":"Part_2/#exercise","title":"Exercise\u00b6","text":"<p>Following the same structure as in part 1. Accumulate for an element $e$ the following equation: $$\\int_\\Omega \\textbf{B}^T \\textbf{D}\\textbf{B} d\\Omega $$</p> <p>Let Young's modulus be 1,000,000 Pa and Poisson's ratio 0.25 and matrices $\\textbf{B}$ and $\\textbf{D}$ as defined above. The structure for iterating over each element is given below. Replace the <code>...</code> placeholder below to complete the code, the following functions in <code>FEM_</code> module may be useful:</p> <ul> <li>integrationPoints()</li> <li>Jacobian()</li> <li>basis_functions_der()</li> <li>dN_To2DOF()</li> <li>stiffness_matrix_2D()</li> </ul> <p>Note: The solution is available in the red hidden cell titled \"Solution\" below.</p>"},{"location":"Part_2/#set-up-empty-matrix-global-matrix-a-and-the-right-hand-side-vector-b","title":"Set up empty matrix global matrix A and the right hand side vector b\u00b6","text":"<p>num_nodes = len(FEM_.mesh.points) A_matrix = np.zeros((num_nodesdomain_dim, num_nodesdomain_dim)) ## note that for each node there are 2 d.o.f b = np.zeros((num_nodes*domain_dim,))</p>"},{"location":"Part_2/#now-we-iterate-through-each-element-in-the-mesh-in-the-same-way-before","title":"Now we iterate through each element in the mesh in the same way before\u00b6","text":"<p>for element in FEM_.element_list_2D:</p> <pre><code># ------------ User Input required ------------------------------------------#\n# -- Step 1. Set the integration points IP and their weights \nIPs, IP_weights = FEM_.integrationPoints()\n\n# -- Step 2. Create empty LHS matrix for the element stiffness matrix ------------#\n# -- recall that variable element contains the list of the nodes and that each node has 2 d.o.f\nLHS = np.zeros((len(element)*domain_dim, len(element)*domain_dim)) \n                \n# -- Step 3. Set up for loop to iterate over each integration point ------------#\nfor IP, weight in zip(IPs,IP_weights):\n                \n    # -- Step 4. Get the list of corner nodes in the element and calculate\n    # --------   the Jacobian matrix using function Jacobian in FEM_module\n    e_nodes_xy = FEM_.global_node_coords[element][:,:3]\n    detJ, JMat = FEM_.Jacobian(IP, e_nodes_xy)\n    \n    # -- Step 5. Calculate the derivative basis functions at the integration point \n    # --------   use the function basis_functions_der() and multiply it by the inverse of the Jacobian matrix\n    der_matrix = FEM_.basis_functions_der(IP)\n    der_matrix_JInv = np.matmul(np.linalg.inv(JMat), der_matrix)\n    \n    # -- Step 6. Transform the derivative matrix into the B described above\n    # --------  use the function dN_To2DOF() in FEM_module\n    B = FEM_.dN_To2DOF(der_matrix_JInv) \n    # -- Step 7. Take the transpose of the matrix B\n    BT =  B.transpose()\n    # -- Step 8. Calculate matrix D. You can use the function stiffness_matrix_2D in FEM module\n    # --------   use the material properties Youngs_modulus and Poisson_ratio defined above\n    D = FEM_.stiffness_matrix_2D(Youngs_modulus,Poisson_ratio)        \n    \n    # -- Step 9. Multiply BT by D\n    BT = np.matmul(BT, D)\n    # -- Step 10. Multiply the matrix from Step 9 by B\n    BT = np.matmul(BT, B)\n    # -- Step 11. Multiply the final matrix by Jacobian determinant and weight of the integration point\n    BT = BT * weight*(detJ) ## currently assume all the weight of IP are the same\n    # -- Step 12. Add the resulting matrix to the element stiffness matrix LHS\n    LHS += BT     \n# -- Step 13. Accumulate the element stiffness matrix LHS to global matrix A\n# ----------  The accumulation of the first d.o.f for the node is given as a hint\nfor i in range(len(element)):\n    for j in range(len(element)):\n        col = int(element[i])\n        row = int(element[j])\n        A_matrix[row*domain_dim,col*domain_dim]+= LHS[int(j*domain_dim)][int(i*domain_dim)] # xx\n        A_matrix[row*domain_dim,col*domain_dim+1]+= LHS[int(j*domain_dim)][int(i*domain_dim+1)] # xy\n        A_matrix[row*domain_dim+1,col*domain_dim]+= LHS[int(j*domain_dim+1)][int(i*domain_dim)] # y\n        A_matrix[row*domain_dim+1,col*domain_dim+1]+= LHS[int(j*domain_dim+1)][int(i*domain_dim+1)] # y\n\n```\nEnd of Solution</code></pre>"},{"location":"Part_2/#step-4-apply-boundary-conditions","title":"Step 4. Apply Boundary Conditions\u00b6","text":"<p>Let us now deal with the right hand side of the equation</p> <p>$$\\int_\\Omega \\textbf{B}^T \\textbf{D}\\textbf{B} d\\Omega = \\int_{d\\Gamma}\\sigma \\cdot \\textbf{n}d\\Gamma\\$$.   As mentioned previously $\\Gamma$ is the boundary of the domain and $\\sigma$ are the stresses acting due to load in the direction $n$ normal to boundary, therefore the right hand side forms a boundary condition, known as Neumann boundary condition.  #### Dirichlet Boundary Conditions There are several types of boundary conditions that exist for differential equations. In previous notebook we applied Dirichlet boundary conditions, where we know the value of a solution $u$ at specific points. Therefore we are able to set the solution nodes at those points to that value. These boundary conditions usually are written as  $$u_x(L,0)=0, u_y(L,0)=0,$$  meaning that the solution is $0$ for both $u_x$ and $u_y$ degrees of freedom at the point $(L,0)$ in global coordinates.   #### Neumann Boundary Conditions Another common type of boundary condition is the Neumann boundary condition, which is applied in this case. This condition specifies the derivative of the solution at certain points rather than the solution value itself. For instance, applying a load or force to the domain, as seen in this example, is a typical Neumann boundary condition. In such cases, the exact solution value at the boundary is unknown; instead, we only have information about how it behaves relative to adjacent nodes. As a result, we cannot directly assign a specific value to the right-hand side vector as before, requiring a different approach  In FEM, when assembling the left-hand side matrix, our goal is to approximate the behavior of the differential equation on an element-by-element basis. To capture the behavior of the derivative at a boundary, we follow the same principle but apply it along the boundary elements. These boundary elements are always one dimension lower than the domain elements; in this case, they are line elements with three nodes per element, as illustrated below  &lt;img src=\"img/line_element_diag.png\" alt=\"line_element\" width=\"300\"&gt;  We follow similar process of accumulation for every element at the boundary using one-dimensional basis function and we add it to the RHS vector $b$ instead of the matrix $A$.  Note: for numerical simulations it is insufficient to use only Neumann boundary conditions. Due to the nature of setting the Neumann boundary conditions that requires integration, there can be arbitrary many solutions unless we specify solutions at certain points using the Dirichlet boundary conditions.  #### Cantilever Example In our example we have a combination of boundary conditions, on the left is the Neumann boundary conditions due to the force being applied and on the right is the Dirichlet boundary condition due to the cantilever being fixed to the wall at three points and it cannot move.  $$u_x(L,0)=0, u_y(L,0)=0, u_x(L,c)=u_x(L,+c)=0$$  For Neumann boundary condition, the load $P$ is applied at the point on the cantilever and we need to express it in terms of forces acting in the $x$ and $y$ directions. This can be done by using traction vector $\\textbf{t}$, that leads to the following formulation:  $$\\int_{d\\Gamma}\\sigma \\cdot \\textbf{n} d\\Gamma = \\int_{d\\Gamma} N\\cdot\\textbf{t}d\\Gamma$$.   where $\\textbf{t}$ is the traction vector defined as  $$\\textbf{t} = \\begin{bmatrix}\\textbf{t}_x \\\\ \\textbf{t}_y \\end{bmatrix} = \\begin{bmatrix} 0 \\\\-\\frac{3P}{4c}\\left[1-\\left(\\frac{y}{c}\\right)^2\\right]\\end{bmatrix}$$  and $N$ is a matrix of line element shape functions: $$N = \\begin{bmatrix} N_1 &amp; 0 \\\\ 0 &amp; N_1 \\\\\\vdots &amp; \\vdots \\\\N_n &amp; 0 \\\\0 &amp; N_n \\end{bmatrix}$$</p> <p>For details on how traction forces are calculated refer to Section Section 2.2 of book \"The Finite Element Method: Its Basis and Fundamentals\" By Olek C Zienkiewicz, Robert L. Taylor, J.Z. Zhu \u00b7 2005</p>"},{"location":"Part_2/#exercise","title":"Exercise\u00b6","text":"<p>Identify the nodes and line elements on the right and left boundaries. Recall that the left boundary lies along the line $x=0$ and the right is along the line $x=L$.</p> <p>Hint: you can <code>mesh.points</code> in <code>FEM_</code> module to find a list of global coordinates for all the nodes and you can use <code>numpy</code> functions <code>np.where</code> and <code>np.isclose</code> to check which points lie on the left and right boundaries based on their $x$ coordinates</p> <p>Note: The solution is available in the red hidden cell titled \"Solution\" below.</p>"},{"location":"Part_2/#-end-of-user-input-","title":"------------ End of User Input ------------------------------------------#\u00b6","text":""},{"location":"Part_2/#find-line-elements-that-have-all-nodes-the-list-of-nodes_on_left_-boundary","title":"Find line elements that have all nodes the list of nodes_on_left_ boundary\u00b6","text":"<p>if FEM_.degree == 1: element_types = \"line\" elif FEM_.degree == 2: element_types = \"line3\"</p> <p>result = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_left_), axis=1) elements_left_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]</p>"},{"location":"Part_2/#find-line-elements-that-have-all-nodes-the-list-of-nodes_on_left_-boundary","title":"Find line elements that have all nodes the list of nodes_on_left_ boundary\u00b6","text":"<p>result = np.all(np.isin(FEM_.mesh.cells_dict[element_types], nodes_on_right_), axis=1) elements_right_=FEM_.mesh.cells_dict[element_types][np.where(result)[0]]</p> <p>print(\"The list of elements on the left boundary are\\n\", elements_left_) print(\"The list of elements on the right boundary are\\n\", elements_right_)</p> <pre><code>```\nEnd of Solution</code></pre>"},{"location":"Part_2/#exercise-accumulate-the-neumann-boundary-condition","title":"Exercise. Accumulate the Neumann Boundary Condition\u00b6","text":"<p>Using the equation of the external forces in terms of traction forces apply the Neumann boundary conditions along the left boundary. Recall that we apply</p> <p>$$\\int_{d\\Gamma} N\\cdot\\textbf{t}d\\Gamma$$</p> <p>where $N$ are the line shape functions and traction vector $t$ is $$\\textbf{t} = \\begin{bmatrix}\\textbf{t}_x \\\\ \\textbf{t}_y \\end{bmatrix} = \\begin{bmatrix} 0 \\\\-\\frac{3P}{4c}\\left[1-\\left(\\frac{y}{c}\\right)^2\\right]\\end{bmatrix}$$</p> <p>and we use Gaussian integration for line elements.</p> <p>Hint: The basis functions for one-dimension quadratic elements are given below along with the suitable integration points and the Jacobian.</p> <p>Note: The solution is available in the red hidden cell titled \"Solution\" below.</p>"},{"location":"Part_2/#exercise-add-the-dirichlet-boundary-conditions","title":"Exercise. Add the Dirichlet Boundary Conditions\u00b6","text":"<p>Apply the Dirichlet boundary conditions on the right hand side:</p> <p>$$u_x(L,0)=0$$, $$u_y(L,0)=0$$, $$u_x(L,c)=u_x(L,+c)=0$$</p> <p>We apply these in the exact same way as in exercise in Part 1, but keep in mind that for each node first is $u_x$ displacement followed by $u_y$.</p> <p>Note: The solution is available in the red hidden cell titled \"Solution\" below.</p>"},{"location":"Part_2/#step-4-solve-the-linear-system-of-equations","title":"Step 4. Solve the Linear System of Equations\u00b6","text":""},{"location":"Part_2/#step-5-solution-analysis","title":"Step 5. Solution Analysis\u00b6","text":"<p>Final step in running a numerical simulation is evaluating the results.</p> <p>Similarly to the exercise with temperature we can view the solution in Paraview using a <code>vtk</code> output. We will use the function <code>write_vtk</code> to create a <code>vtk</code> file. Opening it in Paraview we can  use the \"Warp by Vector\" function to see how the cantilever is expected to deform: the white outline shows the original cantilever and the grey shape is the cantilever after load is applied.</p> <p>Note: It is also possible to view the <code>vtk</code> files online without downloading Paraview. The file can be uploaded to the following website, which provides a limited version of Paraview:</p> <p>https://kitware.github.io/glance/app/</p>"},{"location":"Part_2/#solution-sample","title":"Solution Sample\u00b6","text":"<p>Viewing the solution in Paraview using <code>vtk</code> files shows the general behaviour of the beam. It is good for sense checking the solution to make sure there is nothing obviously wrong, but it doesn't show how accurate the solution.</p> <p>We can also plot the displacement along a line in the beam and compare against the analytical solution, which is coded in the FEM_model class. Let us arbitrarily choose the top boundary for plotting, the code below identifies the nodes along the top boundary and finds the analytical solution for displacement in $x$ and $y$ direction. The results from the FEM solution is plotted against the analytical solutions.</p> <p>You can change the variable <code>test_line_though</code> below to identify a different line through the cantilever.</p>"},{"location":"Part_2/#step-6-error-analysis","title":"Step 6. Error Analysis\u00b6","text":"<p>There are several ways to calculate the errors in numerical solutions with different types of errors suited for different situations. The most common errors:</p> <ul> <li>Max error: the maximum error in the simulation: $$\\max_i(|x_{approx,i} - x_{true,i}|)$$</li> <li>Absolute error: absolute difference between approximate solution and true solution. Best used where all values are of the same magnitude and scale. $$\\|e\\|_1 = \\frac{1}{n}\\sum_{i=1}^{n}(|x_{approx_i} - x_{true_i}|)$$</li> <li>Relative error: the difference between the numerical solution and true solution are normalised by the magnitude of the true solution. This is used in cases where the values are of different magnitudes. However, if the true solution is zero for any of the nodes or has very small values, this formulation will cause issues. $$e_r=\\frac{1}{n}\\sum_{i=1}^{n}(\\frac{|x_{approx_i} - x_{true_i}|}{|x_{true_i}|})$$</li> <li>MSE error (Mean Square Error). This calculates the magnitude of the errors with focus on the errors of large magnitude: $$ \\|e\\|_2 = \\frac{1}{n}{\\sum_{i=1}^{n} (x_{\\text{approx},i} - x_{\\text{true},i})^2} $$</li> </ul> <p>The goal of the error analysis is to understand how the error is changing as we refine the mesh. We expect the numerical solution to converge to the analytical solution for finer meshes, and the error to reduce. We have prepared a module <code>Run_Cantilever_Example</code> takes contains all the required functions to run the whole exercise from step 1 to step 4. This allows to solve the problem and calculate the errors in one <code>for</code> loop, while iterating over the different element sizes.</p>"},{"location":"Part_2/#convergence-analysis","title":"Convergence Analysis\u00b6","text":"<p>A module <code>Run_Cantilever_Example</code> contains all the steps to run a simulation of Cantilever example for a given mesh size. Let us run the analysis for varying  element sizes of 4,2, 1.45, 0.9 and 0.6 and for each mesh calculate the following errors:</p> <ul> <li>max</li> <li>average absolute error</li> <li>MSE error</li> </ul>"},{"location":"Part_2/#neumann-bc-vs-dirichlet-bc","title":"Neumann BC vs Dirichlet BC\u00b6","text":"<p>Neumann boundary conditions are common in physical simulations and are often unavoidable. However, it's important to understand how they influence the behavior and accuracy of the solution.</p> <p>To explore this, we revisit the cantilever beam example using the same element sizes as before, with the addition of a coarse mesh size of 3.0. This time, we replace the Neumann boundary conditions with Dirichlet boundary conditions. Although the original problem does not specify displacement values on the left boundary, we can use the known analytical solution to impose these values directly as Dirichlet conditions. This allows us to clearly compare how the type of boundary condition affects the error.</p> <p>From the plots below, we see a noticeable difference:</p> <ul> <li><p>With Neumann boundary conditions, the solution requires mesh refinement to converge \u2014 an element size of 3.0 is too coarse.</p> </li> <li><p>With Dirichlet boundary conditions, the solution converges immediately, even on the coarsest mesh.</p> </li> </ul> <p>This contrast arises because Dirichlet conditions directly fix specific values in the solution, effectively reducing the number of unknowns and providing stronger constraints. Neumann conditions, on the other hand, apply constraints on the derivative (such as forces or fluxes), which do not fix the solution values directly. As a result, convergence under Neumann conditions depends more heavily on mesh resolution.</p>"},{"location":"Part_2/#final-note","title":"Final Note\u00b6","text":"<p>The Finite Element Method is a powerful numerical technique that enables us to solve complex physical problems that would otherwise be impossible to solve. Beyond what has been presented here, the complexity of FEM solutions can further increase with:</p> <ul> <li><p>Coupled Problems: Solving multiple interacting quantities simultaneously, such as displacement and fluid pressure in hydromechanical simulations.</p> </li> <li><p>Time-Dependent Problems: Using FEM at each time step while employing a time-stepping algorithm to evolve the solution over time.</p> </li> <li><p>Alternative Basis Functions: While FEM traditionally uses polynomial basis functions, a growing field of study explores the use of B-spline basis functions, leading to Isogeometric Analysis (IGA), where the mesh consists of B-splines instead of standard finite elements.</p> </li> </ul> <p>There are also some challenges in using FEM, that have to be considered:</p> <ul> <li><p>Mesh Generation: FEM is highly mesh-dependent, especially for complex problems. Proper mesh refinement is crucial, as an incorrectly meshed domain can lead to inaccurate results. Mesh generation is an active areas of research and a good meshing tool can be costly.</p> </li> <li><p>Computational Cost: High-resolution meshes for complex geometries lead to large linear systems that are computationally expensive to solve. They may require large memories or time to solve a problem to the required degree of accuracy.</p> </li> <li><p>Numerical Instabilities: Poorly conditioned linear systems can arise from inadequate meshing or physical quantities with vastly different magnitudes, making the solution process difficult. Incorrectly stated boundary conditions can also lead to instabilities.</p> </li> <li><p>Nonlinear Problems: FEM typically relies on forming a weak formulation of equations that are linear. However, many real-world problems, such as those involving friction, introduce nonlinearity, requiring additional numerical techniques to ensure convergence and stability.</p> </li> </ul>"}]}